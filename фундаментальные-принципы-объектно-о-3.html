<!DOCTYPE html>
<html lang="ru-RU">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.24">
    <meta name="theme-color" content="#ffffff"><meta name="yandex-verification" content="bbf10c47bf8b55fb"><link rel="icon" href="/assets/favicons/favicon.svg"><link rel="mask-icon" href="/assets/favicons/mask-icon.svg" color="red"><link rel="apple-touch-icon" href="/assets/favicons/apple-touch-icon.png"><link rel="manifest" href="manifest.json"><script>
	    var __rm__config = {
        projectId: '-Mibn7-xoaevC6Q4qq9f',
        locale: 'ru',
        contextWidget: 0,
        embedBtn: 0,
        floatingBtn: 1,
        floatingBtnPosition: 'left',
        floatingBtnStyle: 'light',
			};
    </script><script src="https://widget.revisionme.com/app.js" defer="defer" id="rm_app_script"></script><title>Фундаментальные принципы объектно ориентированного проектирования (Часть 3): Полиморфизм | Way23</title><meta name="description" content="Блог о программировании">
    <link rel="preload" href="/assets/js/runtime~app.25176522.js" as="script"><link rel="preload" href="/assets/css/styles.1005c642.css" as="style"><link rel="preload" href="/assets/js/1812.ebb0a1a7.js" as="script"><link rel="preload" href="/assets/js/app.b6198e79.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.1005c642.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Way23</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="Главная"><!--[--><!--]--> Главная <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/categories.md" class="nav-link" aria-label="По категориям"><!--[--><!--]--> По категориям <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/contacts.md" class="nav-link" aria-label="Контакты"><!--[--><!--]--> Контакты <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="Главная"><!--[--><!--]--> Главная <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/categories.md" class="nav-link" aria-label="По категориям"><!--[--><!--]--> По категориям <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/contacts.md" class="nav-link" aria-label="Контакты"><!--[--><!--]--> Контакты <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--]--></ul><!--[--><!--]--></aside><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="frontmatter-title" tabindex="-1"><a class="header-anchor" href="#frontmatter-title" aria-hidden="true">#</a> Фундаментальные принципы объектно ориентированного проектирования (Часть 3): Полиморфизм</h1><p>Вольный перевод статьи <a href="https://schellingerhout.github.io/design%20patterns/OODesign3/" target="_blank" rel="noopener noreferrer">Fundamental Object Oriented Design principles (Part 3): Polymorphism<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p><p>Рассмотрим Полиморфизм предоставляемый объектно ориентированными языками программирования.</p><p>Это третья часть серии об объектно ориентированном проектировании. Для того чтобы понять почему изучение шаблонов проектирования важно, мы должны начать с рассмотрения того что такое хороший объектно ориентированный дизайн приложения. Объектно ориентированные языки предоставляют уникальные возможности которые содействуют хорошему дизайну приложения.</p><p>Рассматриваемые принципы проектирования применены для не объектно ориентированных языков, но с большими сложностями.</p><h2 id="что-такое-полиморфизм" tabindex="-1"><a class="header-anchor" href="#что-такое-полиморфизм" aria-hidden="true">#</a> Что такое Полиморфизм?</h2><p>Когда мы ссылаемся на объект мы хотим чтобы его поведение определялось типом объекта, а не типом ссылки которую мы используем. Обращение может идти даже через абстрактный тип (например, class abstract в Delphi), всё равно должны вызываться методы типа конкретного экземпляра объекта на который указывает ссылка. Это суть полиморфизма. Как вы видели в <a href="https://way23.ru/%D1%84%D1%83%D0%BD%D0%B4%D0%B0%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE/" target="_blank" rel="noopener noreferrer">разделе про абстракцию<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> мы можем взаимодействовать с объектами через переменную с типом класса-предка, хотя объект, на который ссылается переменная, на самом деле является экземпляром класса-потомка.</p><p>Наиболее общее понимание полиморфизма в том что метод может быть виртуальным. Это означает что класс-потомок может переопределить метод и заменить реализацию предка на свою собственную.</p><h2 id="переопределение-виртуального-метода" tabindex="-1"><a class="header-anchor" href="#переопределение-виртуального-метода" aria-hidden="true">#</a> Переопределение виртуального метода</h2><p>Мы рассмотрели некоторые вещи когда рассматривали <a href="https://way23.ru/%D1%84%D1%83%D0%BD%D0%B4%D0%B0%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE/" target="_blank" rel="noopener noreferrer">концепцию абстракции<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> через виртуальный метод, но в том случае базовый метод был абстрактный и не имел реализации.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type
  TCurve = class
  public
     function GetStartPoint: TPoint; virtual; abstract;   // TPoint не объявлен в этом посте
  end;

  TArc = class(TCurve)
  public
    function GetStartPoint: TPoint; override;
  end;

  TLine = class(TCurve)
  public
    function GetStartPoint: TPoint; override;
  end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Давайте используем похожую структуру, но сделаем замену более явной. Наш метод заменит метод определённый в предке.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type
  TDog = class
  public
    function Bark: string; virtual;   // Woof!
  end;

  TPoodle = class(TDog)
  public
    // это метод подменяет однодоменный метод в TDog
    function Bark: string; override;   // Yap!
  end;

  TToyPoodle = class(TPoodle)
  public
    // это метод подменяет однодоменный метод в TDog и в TPoodle
    function Bark: string; override; // Yip!
  end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>Если мы создали объекты классов <code>TPoodle</code>, <code>TToyPoodle</code> или <code>TDog</code> и ссылаемся на них через переменную типа TDog то мы можем вызвать метод <code>Bark()</code>, причём будет вызван метод именно того класса к которому относится реальный объект, мы даже можем не знать что именно это за класс.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>// Если в переменной ADogList содержаться объекты классов TPoodle, TDog и TToyPoodle то функция вернёт &quot;Yap! Woof! Yip!&quot;

function MidnightChoir(ADogList: TList&lt;TDog&gt;) : string;
var
  LDog : TDog;
  LBarkString: string;
begin
  for LDog in ADogList do
    LBarkString := LBarkString + &#39; &#39; + LDog.Bark(); // Нам не требуется знать действительный тип объекта. Всегда будет вызван подходящий метод Bark
  result := copy(LBarkString, 2, Length(LBarkString)-1);     // удаляем &#39; &#39;
end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><h2 id="перезагрузка-функции-и-перегрузка-операторов" tabindex="-1"><a class="header-anchor" href="#перезагрузка-функции-и-перегрузка-операторов" aria-hidden="true">#</a> Перезагрузка функций и перегрузка операторов</h2><p>Мы обычно не думаем о перегрузке (<code>overload</code>) как о полиморфизме, но она также позволяет добавить в класс больше функциональности оставляя интерфейс более сжатым. Часто этот тип полиморфизма применяется и без ООП. При вызове перегруженной функции объекта корректный метод выбирается на основе названия функции и списка параметров функции, которые уникальны для каждой перегруженного метода.</p><p>Ниже общий пример использования полиморфизма через перегрузку функций. Объект потока (<code>TMyStreamReader1</code>) содержит методы для чтения данных: <code>ReadBoolean</code>, <code>ReadDouble</code>, <code>ReadInteger</code>. При использовании объекта придётся в каждом случае проверять тип переменной и использовать соответствующую функцию. Гораздо проще вызвать метод <code>Read</code> и получить вызов корректной версии метода в зависимости от сигнатуры (<code>TMyStreamReader2</code>).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TMyStreamReader1 = class(TMyGenericStreamReader)
public
 function ReadBoolean(var Buffer: Boolean): Longint;
 function ReadInteger(var Buffer: Integer): Longint;
 function ReadSingle(var Buffer: Single): Longint;
 function ReadDouble(var Buffer: Double): Longint;
end;

TMyStreamReader2 = class(TMyGenericStreamReader)
public
 function ReadData(var Buffer: Boolean): Longint; overload;
 function ReadData(var Buffer: Integer): Longint; overload;
 function ReadData(var Buffer: Single): Longint; overload;
 function ReadData(var Buffer: Double): Longint; overload;
end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Перегрузка операторов идентична с перегрузкой функций, но имеет небольшие отличия в синтаксисе. Операторы обычно не применяются к классам. Левая и правая сторона от инфиксного оператора становятся двумя аргументами, возвращаемое значение определяет результат функции.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>PointRecord = record
  x,y,z : double;

 class operator Multiply(P1: PointRecord; P2: PointRecord): Double; // скалярное произведение P1*P2
 class operator Multiply(P: PointRecord; d: double): PointRec; // d*P
 class operator Multiply(d: double; P: PointRecord): PointRec; // P*d
end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="наследование" tabindex="-1"><a class="header-anchor" href="#наследование" aria-hidden="true">#</a> Наследование</h2><p>Мы уже видели что можем унаследовать одни класс от другого и переопределить виртуальные (<code>virtual</code>) методы родительского класса. Если не переопределять виртуальные методы, то они унаследуются из родительского класса. Например, если мы объявим публичный не виртуальный метод <code>TDog.Pant()</code>, то мы увидим его когда будем ссылаться на наш объект через более специфичный класс (класс-потомок).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type
  TDog = class
  public
    function Pant: string; 
    function Bark: string; virtual;   // Woof!
  end;

  THound = class(TDog) // наследуется из TDog, но не переопределяет Bark(). Если мы вызовем Bark, то мы получим Woof! объявленный в TDog 
  end;

  TPoodle = class(TDog)
  public
   // Этот метод заменит одноимённый в TDog 
   function Bark: string; override;   // Yap!
  end;

  TMaltesePoodle = class(TPoodle) // Наследуется из TPoodle, но не переопределяет Bark(). Если мы вызовем Bark, то получим Yap! объявленный в TPoodle
  end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><h2 id="субтипирование" tabindex="-1"><a class="header-anchor" href="#субтипирование" aria-hidden="true">#</a> Субтипирование</h2><p>Субтипирование (Subtyping) применяется к наследованию интерфейсов. Думаю, что название &quot;субтипирование&quot; неудачное потому что классы связываются через отношение &quot;является&quot; со своими предками и каждый класс в сущности более специализированный тип своего родителя. &quot;Расширение интерфейса&quot; может быть технически более корректным термином. В этом случае интерфейс который наследуется от другого действительно расширяет контракт, наследуемый интерфейс может добавлять больше требований к определению, но не может убирать их. В надуманном примере ниже любой объект который реализует <code>IEquatable</code> должен также полностью удовлетворять <code>IComparable</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type
  IComparable = interface(IInterface)
    function CompareTo(AObject: TObject): Integer;
  end;

  IEquatable = interface(IComparable)
    function EqualTo(AObject: TObject): Boolean;
  end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Расширение интерфейса не диктует путь которым классы должны реализовывать сигнатуры указанных функций, оно только требует чтобы функции присутствовали. Объекты которые удовлетворяют требованиям конкретного интерфейса должны также также удовлетворять требованиям полной иерархии этого интерфейса.</p><p>Существуют случаи когда наследование интерфейса действительно представляет субтипирование. Это случай когда интерфейс определяется похожим на чистый абстрактный класс. В этом случае мы можем иметь псевдо-отношение &quot;является&quot; между интерфейсам.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type
  IMyABCList = Interface
    // Детали не важны. Предполагайте что интерфейс определяет индексирование, добавление и удаление элементов
  end;

  IMyEnumerableABCList = Interface(IMyABCList)
    function GetEnumerator: IEnumerator;
  end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p><code>IMyEnumerableABCList</code> действительно выглядит как подтип <code>IMyABCList</code>. Можно применить эту иерархию интерфейсов к классам независимо от их структуры наследования. Сигнатуры определения методов и свойств наследуются от супертипа к подтипу, но поведения реализованных методов не определено в подтипах (или вообще в интерфейсах).</p><p>Интерфейсы сами по себе являются полиморфными помощниками. Они не содержат конкретного когда. когда мы ссылаемся на объект через интерфейс фактическая реализация обеспечивается объектом и его иерархией, мы знаем только что контракт интерфейса выполнен.</p><h2 id="резюме" tabindex="-1"><a class="header-anchor" href="#резюме" aria-hidden="true">#</a> Резюме</h2><p>Полиморфизм редуцирует большое количество методов к нескольким, в которых специализация выводится из конкретного типа, сигнатуры параметров, или объекта который удовлетворяет интерфейсу.</p><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Последниее изменение: </span><span class="meta-item-info">24.08.2023, 06:42:55</span></div><!----></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script src="/assets/js/runtime~app.25176522.js" defer></script><script src="/assets/js/1812.ebb0a1a7.js" defer></script><script src="/assets/js/app.b6198e79.js" defer></script>
  </body>
</html>
