<!DOCTYPE html>
<html lang="ru-RU">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <meta name="generator" content="VuePress 2.0.0-beta.24">
    <meta name="theme-color" content="#ffffff"><meta name="yandex-verification" content="bbf10c47bf8b55fb"><link rel="icon" href="/assets/favicons/favicon.svg"><link rel="mask-icon" href="/assets/favicons/mask-icon.svg" color="red"><link rel="apple-touch-icon" href="/assets/favicons/apple-touch-icon.png"><link rel="manifest" href="manifest.json"><script>
	    var __rm__config = {
        projectId: '-Mibn7-xoaevC6Q4qq9f',
        locale: 'ru',
        contextWidget: 0,
        embedBtn: 0,
        floatingBtn: 1,
        floatingBtnPosition: 'left',
        floatingBtnStyle: 'light',
			};
    </script><script src="https://widget.revisionme.com/app.js" defer="defer" id="rm_app_script"></script><title>Написание простого DSL компилятора на Delphi (Intermezzo) | Way23</title><meta name="description" content="Блог о программировании">
    <link rel="preload" href="/assets/js/runtime~app.25176522.js" as="script"><link rel="preload" href="/assets/css/styles.1005c642.css" as="style"><link rel="preload" href="/assets/js/1812.ebb0a1a7.js" as="script"><link rel="preload" href="/assets/js/app.b6198e79.js" as="script">
    <link rel="stylesheet" href="/assets/css/styles.1005c642.css">
  </head>
  <body>
    <div id="app"><!--[--><div class="theme-container no-sidebar"><header class="navbar"><div class="toggle-sidebar-button" title="toggle sidebar" aria-expanded="false" role="button" tabindex="0"><div class="icon" aria-hidden="true"><span></span><span></span><span></span></div></div><span><a href="/" class=""><!----><span class="site-name">Way23</span></a></span><div class="navbar-links-wrapper" style=""><!--[--><!--]--><nav class="navbar-links can-hide"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="Главная"><!--[--><!--]--> Главная <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/categories.md" class="nav-link" aria-label="По категориям"><!--[--><!--]--> По категориям <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/contacts.md" class="nav-link" aria-label="Контакты"><!--[--><!--]--> Контакты <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><button class="toggle-dark-button" title="toggle dark mode"><svg style="" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M16 12.005a4 4 0 1 1-4 4a4.005 4.005 0 0 1 4-4m0-2a6 6 0 1 0 6 6a6 6 0 0 0-6-6z" fill="currentColor"></path><path d="M5.394 6.813l1.414-1.415l3.506 3.506L8.9 10.318z" fill="currentColor"></path><path d="M2 15.005h5v2H2z" fill="currentColor"></path><path d="M5.394 25.197L8.9 21.691l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 25.005h2v5h-2z" fill="currentColor"></path><path d="M21.687 23.106l1.414-1.415l3.506 3.506l-1.414 1.414z" fill="currentColor"></path><path d="M25 15.005h5v2h-5z" fill="currentColor"></path><path d="M21.687 8.904l3.506-3.506l1.414 1.415l-3.506 3.505z" fill="currentColor"></path><path d="M15 2.005h2v5h-2z" fill="currentColor"></path></svg><svg style="display:none;" class="icon" focusable="false" viewBox="0 0 32 32"><path d="M13.502 5.414a15.075 15.075 0 0 0 11.594 18.194a11.113 11.113 0 0 1-7.975 3.39c-.138 0-.278.005-.418 0a11.094 11.094 0 0 1-3.2-21.584M14.98 3a1.002 1.002 0 0 0-.175.016a13.096 13.096 0 0 0 1.825 25.981c.164.006.328 0 .49 0a13.072 13.072 0 0 0 10.703-5.555a1.01 1.01 0 0 0-.783-1.565A13.08 13.08 0 0 1 15.89 4.38A1.015 1.015 0 0 0 14.98 3z" fill="currentColor"></path></svg></button><!----></div></header><div class="sidebar-mask"></div><aside class="sidebar"><nav class="navbar-links"><!--[--><div class="navbar-links-item"><a href="/" class="nav-link" aria-label="Главная"><!--[--><!--]--> Главная <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/categories.md" class="nav-link" aria-label="По категориям"><!--[--><!--]--> По категориям <!--[--><!--]--></a></div><div class="navbar-links-item"><a href="/contacts.md" class="nav-link" aria-label="Контакты"><!--[--><!--]--> Контакты <!--[--><!--]--></a></div><!--]--></nav><!--[--><!--]--><ul class="sidebar-links"><!--[--><!--]--></ul><!--[--><!--]--></aside><!--[--><main class="page"><!--[--><!--]--><div class="theme-default-content"><!--[--><h1 id="frontmatter-title" tabindex="-1"><a class="header-anchor" href="#frontmatter-title" aria-hidden="true">#</a> Написание простого DSL компилятора на Delphi (Intermezzo)</h1><p>Перевод поста <a href="https://www.thedelphigeek.com/2017/10/writing-simple-dsl-compiler-with-delphi_17.html" target="_blank" rel="noopener noreferrer">Writing a Simple DSL Compiler with Delphi (Intermezzo)<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>.</p><p>Когда я подготавливал статью про компилятор для моего <a href="http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-0/" target="_blank" rel="noopener noreferrer">игрушечного языкового проекта<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>, я обнаружил что концепцию обёртки целой программы в связку анонимных функций (что делает компилятор) чрезвычайно сложна для объяснения. Поэтому я подготовил упрошенную версию компилятора, написанную для очень упрошенного языка... а затем я так и не смог остановится и добавил AST, пакрсер и токинезатор.</p><p>Результатом всего этого является программа <a href="https://github.com/gabr42/SimpleDSLCompiler/blob/master/introduction.dpr" target="_blank" rel="noopener noreferrer">introduction.dpr<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>, автономная программа которая содержит полностью язык (очень тривиальный) вместе с полной документацией, написанная в стиле <a href="https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D0%BC%D0%BE%D1%82%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5" target="_blank" rel="noopener noreferrer">Грамотного программирования<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a>. Упрощено — вы можете читать её сверху вниз как историю.</p><p>В качестве intermezzo и для упрощения моего объяснения компилятора, я опишу эту программу здесь полностью, отформатировав её как пост в блог.</p><h2 id="introduction-dpr" tabindex="-1"><a class="header-anchor" href="#introduction-dpr" aria-hidden="true">#</a> introduction.dpr</h2><p>Эта программа является мягким введением в тему &quot;compiler-compiler&quot; (программ которые генерируют компиляторы или их части). Она написана в стиле Грамотного программирования и предназначена для чтения от начала до конца.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>program introduction;
{$APPTYPE CONSOLE}
{$R *.res}
uses
  System.SysUtils,
  System.Classes,
  System.Character,

  System.Generics.Collections;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Наша задача: мы хотим вычислять выражения в форме</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>   number1 + number2 + ... + numberN
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Все числа целые и позитивные, только один оператор — сложение, переполнение игнорируется.</p><p>Формально, мы можем описать нашу программу следующей грамматикой</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>S → Term
Term → number
Term → Term &#39;+&#39; Term
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Пробельные символы игнорируются парсером и следовательно не являются частью грамматики.</p><p>Мы начнём с очень простого AST который будет хранить разобранную версию программы</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type
  TTerm = class abstract
  end; 

  TAST = TTerm;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>На верху нашего дерева находится &#39;term&#39; (слагаемое). <em>Слагаемое</em> может быть либо <em>константой</em> либо <em>сложением</em>.</p><p><em>Константа</em>, как и можно ожидать, содержит целочисленное значение.</p><p>Здесь мы непоследовательны — язык позволяет только позитивные числа, но AST более общее и допускает негативные числа. Мы будем просто игнорировать это.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>  TConstant = class(TTerm)
  strict private
    FValue: integer;
  public
    constructor Create(AValue: integer);
    property Value: integer read FValue write FValue;
  end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><em>Сложение</em> — бинарная операция над двумя <em>слагаемыми</em> (левым и правым).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>  TAddition = class(TTerm)
  strict private
    FTerm1: TTerm;
    FTerm2: TTerm;
  public
    constructor Create(ATerm1, ATerm2: TTerm);
    destructor  Destroy; override;
    property Term1: TTerm read FTerm1 write FTerm1;
    property Term2: TTerm read FTerm2 write FTerm2;
  end;

constructor TConstant.Create(AValue: integer);
begin
  inherited Create;
  FValue := AValue;
end;

constructor TAddition.Create(ATerm1, ATerm2: TTerm);
begin
  inherited Create;
  FTerm1 := ATerm1;
  FTerm2 := ATerm2;
end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>Объект <code>TAddition</code> является владельцем своих дочерних объектов.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>destructor TAddition.Destroy;
begin
  FreeAndNil(FTerm1);
  FreeAndNil(FTerm2);
  inherited;

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Следующая функция строит AST из массива чисел. Владелец отвечает за уничтожение полученного AST.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CreateAST(const values: TArray): TAST;
var
  iValue: integer;
begin
  if Length(values) = 0 then

    Exit(nil);
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Мы будем создавать <em>слагаемые</em> из массив в начиная с конца к началу и использовать промежуточные результаты как слагаемые в следующих слагаемых.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>  Result := TConstant.Create(values[High(values)]);

  for iValue := High(values) - 1 downto Low(values) do
    Result := TAddition.Create(TConstant.Create(values[iValue]), Result);

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Вызов <code>CreateAST([1, 2, 3])</code> создаст следующее AST с тремя узлами:</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TAddition
   Term1 = TConstant
           Value = 1
   Term2 = TAddition
           Term1 = TConstant
                   Value = 2
           Term2 = TConstant
                   Value = 3
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Давайте сделаем из этого тест.</p><p>Сначала, несколько вспомогательных функций, которые одновременно проверяют и преобразовывают тип.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function IsConstant(term: TTerm; out add: TConstant): boolean;
begin
  Result := term is TConstant;
  if Result then
    add := TConstant(term);
end;

function IsAddition(term: TTerm; out add: TAddition): boolean;
begin
  Result := term is TAddition;
  if Result then
    add := TAddition(term);

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>И теперь реальный тест.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TestCreateAST;
var
  add1  : TAddition;
  add2  : TAddition;
  ast   : TAST;
  const1: TConstant;
  const2: TConstant;
  const3: TConstant;
begin
  ast := CreateAST([1, 2, 3]);
  try
    if assigned(ast)
       and IsAddition(ast, add1)
       and IsConstant(add1.Term1, const1) and (const1.Value = 1)
       and IsAddition(add1.Term2, add2)
       and IsConstant(add2.Term1, const2) and (const2.Value = 2)
       and IsConstant(add2.Term2, const3) and (const3.Value = 3)
    then
      // everything is fine
    else
      raise Exception.Create(&#39;CreateAST is not working correctly!&#39;);
  finally FreeAndNil(ast); end;

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>Мы напишем просто парсер который создаст AST из выражения в форме <code>number1 + number2 + ... numberN</code>.</p><p>Наш &quot;язык&quot; имеет только два токена: &#39;number&#39; (число) и &#39;addition&#39; (сложение). Пробельные символы не важны будут игнорироваться токинезатором (лексическим анализатором). Все не распознанные символы будут возвращать токен &#39;unknown&#39;.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type
  TTokenKind = (tkNumber, tkAddition, tkUnknown);
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Больше информации про токены:</p><ul><li>tkNumber — &quot;\d+&quot;</li><li>tkAddition — &quot;+&quot;</li><li>&quot;\s+&quot; — пропускаются</li><li>tkUnknown — принимает всё остальное: &quot;[^\d+\s]&quot;</li></ul><p>Токинезатор и парсер нуждаются только в следующей информации:</p><ul><li>Входная строка.</li><li>Текущая позиция.</li></ul><p>Класс <code>TStringStream</code> обеспечивает оба эти пункта так что мы будем использовать его.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>  TParserState = TStringStream;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Единственная функция токинезатора возвращает следующий токен и его значение как параметры с модификатором <code>var</code> и возвращает <code>True</code> если пара токен\значение была возвращена и <code>False</code> если достигнут конец потока.</p><p>Эта реализация очень проста, но одновременно крайне неоптимизирована.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function GetToken(state: TParserState; var token: TTokenKind; var value: string): boolean;
var
  nextChar: string;
  position: int64;
begin
  repeat
    nextChar := state.ReadString(1);
    Result := (nextChar &lt;&gt; &#39;&#39;);
    // Ignore whitespace
  until (not Result) or (not nextChar[1].IsWhiteSpace);

  if Result then begin
    value := nextChar[1];

    // Addition
    if value = &#39;+&#39; then
      token := tkAddition

    // Number
    else if value[1].IsNumber then begin
      token := tkNumber;
      repeat
        position := state.Position;
        nextChar := state.ReadString(1);

        // End of stream, stop
        if nextChar = &#39;&#39; then
          break //repeat

        // Another number, append
        else if nextChar[1].IsNumber then
          value := value + nextChar[1]

        // Read too far, retract
        else begin
          state.Position := position;
          break; //repeat
        end;
      until false;
    end

    // Unexpected input
    else
      token := tkUnknown;
  end;

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>Необходимо несколько тестов для токинезатора..</p><p><code>ExpectFail(state)</code> вызывает <code>GetToken</code> и ожидает что он вернёт <code>False</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure ExpectFail(state: TParserState);
var
  token: TTokenKind;
  value: string;
begin
  if GetToken(state, token, value) then
    raise Exception.Create(&#39;ExpectFail failed&#39;);

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>Expect(State, token, value)</code> вызывает <code>GetNextToken</code> и ожидает что он вернёт <code>True</code> и те же токен/значение которые переданы в параметрах.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure Expect(state: TParserState; expectedToken: TTokenKind;   expectedValue: string);
var
  token: TTokenKind;
  value: string;
begin
  if not GetToken(state, token, value) then
    raise Exception.Create(&#39;Expect failed&#39;)

  else if token &lt;&gt; expectedToken then
    raise Exception.CreateFmt(            &#39;Expect encountered invalid token kind (%d, expected %d)&#39;,
            [Ord(token), Ord(expectedToken)])

  else if value &lt;&gt; expectedValue then
    raise Exception.CreateFmt(            &#39;Expect encountered invalid value (%s, expected %s)&#39;,
            [value, expectedValue])
end;

procedure TestGetToken;
var
  state: TParserState;
begin
  state := TParserState.Create(&#39;&#39;);
  ExpectFail(state);
  FreeAndNil(state);

  state := TParserState.Create(&#39;1&#39;);
  Expect(state, tkNumber, &#39;1&#39;);
  ExpectFail(state);
  FreeAndNil(state);

  state := TParserState.Create(&#39;1+22 333 Ab&#39;);
  Expect(state, tkNumber, &#39;1&#39;);
  Expect(state, tkAddition, &#39;+&#39;);
  Expect(state, tkNumber, &#39;22&#39;);
  Expect(state, tkNumber, &#39;333&#39;);
  Expect(state, tkUnknown, &#39;A&#39;);
  Expect(state, tkUnknown, &#39;b&#39;);
  ExpectFail(state);
  FreeAndNil(state);

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>Парсер принимает любую допустимую строку и преобразует её в AST.</p><p>Если программа корректна, он создаст AST для этой программы, вернёт его в параметре <code>ast</code> и результат функции будет <code>True</code>.</p><p>Если программа не корректна, параметр <code>ast</code> будет <code>nil</code> и результат функции <code>False</code>.</p><p>Пустой ввод не допускается.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function Parse(const prog: string; var ast: TAST): boolean;
var
  accept : TTokenKind;
  numbers: TList;
  state  : TParserState;
  token  : TTokenKind;
  value  : string;
begin
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Мы можем легко увидеть как показанная грамматика генерирует следующую последовательность токенов:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>   tkNumber (tkAddition tkNumber)*
</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>(Доказательство опущено в качестве упражнения для читателя)</p><p>Код проверит синтаксис и извлечёт из строки все числа в <code>TArray</code>.</p><p>В конце он передаст этот массив в функцию <code>CreateAST</code> для создания AST.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>   ast := nil;
  Result := false;

  state := TParserState.Create(prog);
  try
    numbers := TList.Create;
    try
      accept := tkNumber;
      while GetToken(state, token, value) do begin
        if token &lt;&gt; accept then
          Exit;
        if accept = tkNumber then begin
          numbers.Add(StrToInt(value));
          accept := tkAddition;
        end
        else
          accept := tkNumber;
      end;

      if accept = tkNumber then
        // Last token in the program was tkAddition, which is not allowed.
        Exit;

      if numbers.Count &gt; 0 then begin
        ast := CreateAST(numbers.ToArray);
        Result := true;
      end;
    finally FreeAndNil(numbers); end;
  finally FreeAndNil(state); end;

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>Нам нужно больше тестов...</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TestParse;
var
  add1  : TAddition;
  add2  : TAddition;
  ast   : TAST;
  const1: TConstant;
  const2: TConstant;
  const3: TConstant;
begin
  if not Parse(&#39;1+2 + 3&#39;, ast) then
    raise Exception.Create(&#39;Parser failed&#39;);
  try
    if assigned(ast)
       and IsAddition(ast, add1)
       and IsConstant(add1.Term1, const1) and (const1.Value = 1)
       and IsAddition(add1.Term2, add2)
       and IsConstant(add2.Term1, const2) and (const2.Value = 2)
       and IsConstant(add2.Term2, const3) and (const3.Value = 3)
    then
      // everything is fine
    else
      raise Exception.Create(&#39;CreateAST is not working correctly!&#39;);
  finally FreeAndNil(ast); end;

  if Parse(&#39;1+2 +&#39;, ast) then begin
    if assigned(ast) then
      raise Exception.Create(&#39;Invalid program resulted in an AST!)&#39;)
    else
      raise Exception.Create(&#39;Invalid program compiled into an empty AST!&#39;);
  end;

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>Для интерпретации этого AST мы будем использовать простую рекурсию.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function InterpretAST(ast: TAST): integer;
var
  add1  : TAddition;
  const1: TConstant;
begin
  if not assigned(ast) then
    raise Exception.Create(&#39;Result is undefined!&#39;);
  // Alternatively, we could use Nullable as result, 
  // with Nullable.Null as a default value.

  if IsConstant(ast, const1) then
    Result := const1.Value
  else if IsAddition(ast, add1) then
    Result := InterpretAST(add1.Term1) + InterpretAST(add1.Term2)
  else
    raise Exception.Create(&#39;Internal error. Unknown AST element: &#39; +      ast.ClassName);

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>Несколько sanity tests всегда приветствуются...</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TestInterpretAST;

  procedure Test(const testName: string; const values: TArray;    expectedResult: integer);
  var
    ast       : TAST;
    calcResult: integer;
  begin
    ast := CreateAST(values);
    if not assigned(ast) then
      raise Exception.CreateFmt(&#39;Compilation failed in test %s&#39;, [testName]);

    try
      calcResult := InterpretAST(ast);
      if calcResult &lt;&gt; expectedResult then
        raise Exception.CreateFmt(
                &#39;Evaluation failed in test %s. &#39; +
                &#39;Calculated result %d &lt;&gt; expected result %d&#39;,
                [testName, calcResult, expectedResult]);
    finally
      FreeAndNil(ast);
    end;
  end;

begin
  Test(&#39;1&#39;, [42], 42);
  Test(&#39;2&#39;, [1, 2, 3], 6);
  Test(&#39;3&#39;, [2, -2, 3, -3], 0);

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>Для компиляции этого AST, мы должны:</p><ul><li>Изменить каждый узел с типом &#39;constant&#39; в анонимную функцию которая возвращает значение этого узла.</li><li>Изменить каждый узел с типом &#39;summation&#39; в анонимную функцию которая возвращает значение двух параметров. <ul><li>Первый - анонимная функция которая вычисляет значение левого слагаемого и</li><li>второй - анонимная функция которая вычисляет значение правого слагаемого</li></ul></li><li><a href="http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Anonymous_Methods_in_Delphi#Variable_Binding_Mechanism" target="_blank" rel="noopener noreferrer">Механизм связывания переменных<span><svg class="icon outbound" xmlns="http://www.w3.org/2000/svg" ariahidden="true" focusable="false" x="0px" y="0px" viewbox="0 0 100 100" width="15" height="15"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path><polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg><!--[--><span class="sr-only">open in new window</span><!--]--></span></a> заботится о получении правильных входных данных</li></ul><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function MakeConstant(value: integer): TFunc;
begin
  Result :=
    function: integer
    begin
      Result := value;
    end;
end;

function MakeAddition(const term1, term2: TFunc): TFunc;
begin
  Result :=
    function: integer
    begin
      Result := term1() + term2();
    end;
end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>Важная точка здесь в том что не <code>MakeConstant</code> не <code>MakeAddition</code> не делает никаких вычислений. Они просто настраивают анонимный метод и возвращают ссылку на него, что более или менее соответствует созданию объекта и возврату его интерфейса, но с добавление затрат на связывание переменных (variable capturing).</p><p>Кстати, так как наш &quot;язык&quot; только вычисляет целочисленные выражения что всегда на выходе даёт целое число, то &quot;функция которая возвращает число&quot; или <code>TFunc</code> точно подходит под наши требования.</p><p>Для &quot;компиляции&quot; AST мы должны использовать рекурсию так как нам нужно создать дочерне-вычисляемые анонимные функции перед их вычислением (как параметры) для создания анонимной функции вычисляющей родительский узел.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CompileAST(ast: TTerm): TFunc;
var
  add1: TAddition;
  const1: TConstant;
begin
  if IsConstant(ast, const1) then
    // this node represents a constant
    Result := MakeConstant(const1.Value)
  else if IsAddition(ast, add1) then
    // this node represent an expression
    Result := MakeAddition(CompileAST(add1.Term1), CompileAST(add1.Term2))
  else

    raise Exception.Create(&#39;Internal error. Unknown AST element: &#39; +      ast.ClassName);
end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Этот код работает корректно потому что захватывает <strong>значение</strong> <code>const1.Value</code>, а не ссылку (указатель) на него. Откуда я это знаю? Потому что функция <code>TestCompileAST</code> явным образом проверяет это поведение.</p><p>Вызывая <code>CompileAST(CreateAST[1,2,3])</code> будет сгенерирована следующая анонимная функция:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>(*
function: integer
begin
  Result :=
    (function: integer
     begin
       Result := 1;
     end)()
    +
    (function: integer
     begin
       Result :=
         (function: integer
          begin
            Result := 2;
          end)()
         +
         (function: integer
          begin
            Result := 3;
          end)();
     end)();

end;
*)
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>(*): я знаю что результатом этого будет уточка памяти так как AST не уничтожается.</p><p>Трудно проверить что сгенерированная анонимная функция в корректной форме, но мы можем запустить её на некотором числе тестов и надеятся что всё ОК 😉</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TestCompileAST;

  procedure Test(const testName: string; const prog: string; expectedResult: integer);
  var
    add1      : TAddition;
    ast       : TAST;
    calcResult: integer;
    code      : TFunc;
    const1    : TConstant;
  begin
    if not (Parse(prog, ast) and assigned(ast)) then
      raise Exception.CreateFmt(&#39;Parser failed in test %s&#39;, [testName]);

    try
      code := CompileAST(ast);
      if not assigned(code) then

        raise Exception.CreateFmt(&#39;Compilation failed in test %s&#39;, [testName]);
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>Давайте удостоверимся что <code>ast.Value</code> был связан по значению а не по ссылке.</p><p>Изменение AST сейчас не должно влиять на скомпилированный код.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>       if (IsAddition(ast, add1) and IsConstant(add1.Term1, const1))
         or IsConstant(ast, const1)
      then
        const1.Value := const1.Value + 1
      else
        raise Exception.CreateFmt(&#39;Unexpected AST format in test %s&#39;,         [testName]);

      calcResult := code(); //execute the compiled code

      if calcResult &lt;&gt; expectedResult then
        raise Exception.CreateFmt(
                &#39;Evaluation failed in test %s. &#39; +
                &#39;Codegen result %d &lt;&gt; expected result %d&#39;,
                [testName, calcResult, expectedResult]);

    finally
      FreeAndNil(ast);
    end;
  end;

begin
  Test(&#39;1&#39;, &#39;42&#39;, 42);
  Test(&#39;2&#39;, &#39;1 + 2 + 3&#39;, 6);
  Test(&#39;3&#39;, &#39;2 + 2 +3+3&#39;, 10);

end;
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>Если все тесты проходят, мы запустим цикл Чтение-Выполнение-Вывод (Read-Eval-Print Loop) так что пользователь сможет проверить наш компилятор.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure RunREPL;
var
  ast : TAST;
  prog: string;
begin
  repeat
    Write(&#39;Enter an expression (empty line exits): &#39;);
    Readln(prog);
    if prog = &#39;&#39; then
      break;

    if not Parse(prog, ast) then
      Writeln(&#39;Syntax is not valid&#39;)
    else
      Writeln(&#39;Result is: &#39;, CompileAST(ast)());
  until false;
end;

begin
   try
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>Запустим все модульные тесты для проверки корректности программы.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>     Writeln(&#39;Running AST creation tests ...&#39;);
    TestCreateAST;

    Writeln(&#39;Running tokenizer tests ...&#39;);
    TestGetToken;

    Writeln(&#39;Running parser test ...&#39;);
    TestParse;

    Writeln(&#39;Running AST interpreter tests ...&#39;);
    TestInterpretAST;

    Writeln(&#39;Running AST compilation tests ...&#39;);
    TestCompileAST;

    RunREPL;
  except
    on E: Exception do begin
      Writeln(E.ClassName, &#39;: &#39;, E.Message);
      Readln;
    end;
  end;
end.
</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><!--]--></div><footer class="page-meta"><!----><div class="meta-item last-updated"><span class="meta-item-label">Последниее изменение: </span><span class="meta-item-info">24.08.2023, 06:42:55</span></div><!----></footer><!----><!--[--><!--]--></main><!--]--></div><!----><!--]--></div>
    <script src="/assets/js/runtime~app.25176522.js" defer></script><script src="/assets/js/1812.ebb0a1a7.js" defer></script><script src="/assets/js/app.b6198e79.js" defer></script>
  </body>
</html>
