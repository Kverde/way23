"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[7450],{58570:(t,e,r)=>{r.r(e),r.d(e,{data:()=>a});const a={key:"v-4470a830",path:"/oracle-%D0%BA%D0%B0%D0%BA-%D0%BD%D0%B5-%D0%BD%D1%83%D0%B6%D0%BD%D0%BE-%D0%B3%D0%B5%D0%BD%D0%B5%D1%80%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D1%82%D1%8C-%D0%BF%D0%B5%D1%80%D0%B2%D0%B8%D1%87%D0%BD%D1%8B%D0%B9.html",title:"Oracle. Как не нужно генерировать первичный ключ",lang:"ru-RU",frontmatter:{title:"Oracle. Как не нужно генерировать первичный ключ",date:"2019-10-22",categories:["Базы данных"],tags:["oracle"]},excerpt:"",headers:[],filePathRelative:"oracle-как-не-нужно-генерировать-первичный.md",git:{updatedTime:1692859375e3}}},69163:(t,e,r)=>{r.r(e),r.d(e,{default:()=>k});var a=r(66252),d=r(3577);const n={id:"frontmatter-title",tabindex:"-1"},s=(0,a._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),l=(0,a.Uk)("Идея поста возникал при прочтении "),o={href:"http://it-blackcat.blogspot.com/2019/10/getting-primary-key-value-after-insert.html",target:"_blank",rel:"noopener noreferrer"},c=(0,a.Uk)("Получение в программе значения первичного ключа после INSERT"),p=(0,a.Uk)("."),i=(0,a.Uk)("В Oracle младше 12 версии нет автоинкрементного поля. Стандратный способ генерации первичных ключей — "),D={href:"https://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_6015.htm",target:"_blank",rel:"noopener noreferrer"},m=(0,a.Uk)("последовательности"),h=(0,a.Uk)(". Но иногда разработчики генерируют первичный ключ таким способом:"),u=(0,a.uE)('<div class="language-sql ext-sql line-numbers-mode"><pre class="language-sql"><code><span class="token keyword">select</span> <span class="token function">max</span><span class="token punctuation">(</span>rid<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token keyword">from</span> <span class="token keyword">table</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Это приводит к проблемам при многопользовательской работе. Типичная ситуация — пользователи одновременно получают новое значение для ПК, а потом вставляют записи:</p><table><thead><tr><th>Пользователь1</th><th>Пользователь2</th></tr></thead><tbody><tr><td>select max(rid) + 1 from table</td><td></td></tr><tr><td></td><td>select max(rid) + 1 from table</td></tr><tr><td>insert</td><td></td></tr><tr><td></td><td>insert</td></tr></tbody></table><p>В результате второй пользователь зависает из-за блокировки. Если же первый пользователь зафиксирует данные, то у второго сработает ограничение по первичному ключу:</p><table><thead><tr><th>Пользователь1</th><th>Пользователь2</th></tr></thead><tbody><tr><td>select max(rid) + 1 from table</td><td></td></tr><tr><td></td><td>select max(rid) + 1 from table</td></tr><tr><td>insert</td><td></td></tr><tr><td></td><td>insert</td></tr><tr><td>commit</td><td></td></tr><tr><td></td><td>ORA-00001: нарушено ограничение уникальности</td></tr></tbody></table><p>Для генерации ПК следует использовать последовательности или специальные механизмы вроде GUID. Иначе будут возникать ошибки.</p>',6),k={render:function(t,e){const r=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[(0,a._)("h1",n,[s,(0,a.Uk)(" "+(0,d.zw)(t.$frontmatter.title),1)]),(0,a._)("p",null,[l,(0,a._)("a",o,[c,(0,a.Wm)(r)]),p]),(0,a._)("p",null,[i,(0,a._)("a",D,[m,(0,a.Wm)(r)]),h]),u],64)}}}}]);