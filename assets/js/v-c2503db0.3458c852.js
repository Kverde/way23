"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[526],{44860:(e,a,l)=>{l.r(a),l.d(a,{data:()=>r});const r={key:"v-c2503db0",path:"/%D1%84%D1%83%D0%BD%D0%B4%D0%B0%D0%BC%D0%B5%D0%BD%D1%82%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B8%D0%BD%D1%86%D0%B8%D0%BF%D1%8B-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D0%BE-%D0%BE-2.html",title:"Фундаментальные принципы объектно ориентированного проектирования (Часть 2): Инкапсуляция",lang:"ru-RU",frontmatter:{title:"Фундаментальные принципы объектно ориентированного проектирования (Часть 2): Инкапсуляция",date:"2019-07-16",categories:["Delphi"],tags:["Delphi","ооп","перевод"]},excerpt:"",headers:[{level:2,title:"Что такое Инкапсуляция?",slug:"что-такое-инкапсуляция",children:[]},{level:2,title:"Объекты могут быть однозначно идентифицированы ссылкой",slug:"объекты-могут-быть-однозначно-идентифицированы-ссылкои",children:[]},{level:2,title:"Объекты хранят данные и функции вместе",slug:"объекты-хранят-данные-и-функции-вместе",children:[]},{level:2,title:"Объекты позволяют скрыть внутреннюю функциональность и приватные данные",slug:"объекты-позволяют-скрыть-внутреннюю-функциональность-и-приватные-данные",children:[]},{level:2,title:"Объекты предоставляют права доступа",slug:"объекты-предоставляют-права-доступа",children:[]},{level:2,title:"В итоге",slug:"в-итоге",children:[]}],filePathRelative:"фундаментальные-принципы-объектно-о-2.md",git:{updatedTime:1692859375e3}}},71780:(e,a,l)=>{l.r(a),l.d(a,{default:()=>g});var r=l(66252),i=l(3577);const n={id:"frontmatter-title",tabindex:"-1"},t=(0,r._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),d=(0,r.Uk)("Вольный перевод статьи "),s={href:"https://schellingerhout.github.io/design%20patterns/OODesign2/",target:"_blank",rel:"noopener noreferrer"},p=(0,r.Uk)("Fundamental Object Oriented Design principles (Part 2): Encapsulation"),c=(0,r.Uk)("."),D=(0,r.uE)('<p>Рассмотрим принцип Инкапсуляции используемый объектно ориентированными языкми программирования.</p><p>Это вторая часть серии об объектно ориентированном проектировании. Чтобы полностью понять почему изучение шаблонов проектирования важно, мы должны начать с рассмотрения того что такое хороший объектно ориентированный дизайн приложения.</p><p>ОО-языки предоставляют уникальные возможности, которые содействуют хорошему дизайну приложения. Рассматриваемые принципы проектирования могут быть применены и для не объектно ориентированных языков, но это потребует больших усилий.</p><p>Эта статья предполагает что вы знакомы как минимум с одним ОО языком программирования. C++, Delphi, C# и Java являются примерами объектно ориентированных языков. В отличии от них JavaScript <em>основан на объектах</em>, в нём используется прототипирование вместо классов. Настоящий ОО язык программирования имеет классы, объекты и очень часто интерфейсы.</p><h2 id="что-такое-инкапсуляция" tabindex="-1"><a class="header-anchor" href="#что-такое-инкапсуляция" aria-hidden="true">#</a> Что такое Инкапсуляция?</h2><p>Объекты являются строительными блоками используемыми в ОО языках программирования. Объекты — структуры которые инкапсулируют данные и функции вместе, это простейший вид инкапсуляции.</p><h2 id="объекты-могут-быть-однозначно-идентифицированы-ссылкои" tabindex="-1"><a class="header-anchor" href="#объекты-могут-быть-однозначно-идентифицированы-ссылкои" aria-hidden="true">#</a> Объекты могут быть однозначно идентифицированы ссылкой</h2><p>Концепция объекта может быть трудна для понимания тех кто пришёл с процедурных или функциональных языков. ООП-разработчики часто сталкиваются с аргументам о том что ООП не предоставляет ничего нового с тем что есть в процедурных языках. Позвольте мне объяснить Инкапсуляцию в форме разговора:</p><blockquote><p>Я: У вас есть машина? Вы: Да Я: Где она сейчас Вы: Снаружи, на парковке Я: Какого она цвета? Вы: Синего Я: Описание сужается примерно до четверти всех автомобилей. Назовите больше деталей. Вы: Это Honda Accord, 2010 года Я: Две машины подходят под это описания. Может быть есть что-то более специфичное? Вы: Мой номер й454ок Я: Итак, это ваша машина? Вы: Да Я: Вы уверены? Вы: Да Я: Почему? Вы: Она соответствует всем требованиям о которых я знаю. Я: Если ты я заменил ваш автомобиль на автомобиль с тем же цветом, маркой, моделью и номерным знаком был бы он вашим? Вы: Хорошо... нет. Я не смог бы сказать сразу что это не моя машина, но я понял бы это когда бы сел в неё и попробовал завести своим ключом. Я: Что если бы она имела идентичный замок? Вы: Вы очень раздражающий, вы знаете об этом? Я: Да, да. Могу я задать последний вопрос? Вы: Хорошо, но вы проверяете моё... Я: Действительно ли вы можете знать что машина ваша без проверки каждого атрибута? Вы: Да Я: Как вы можете сделать это? Извините, Я думаю это не был мой последний вопрос. Вы: Просто я должен смотреть на неё всё время.</p></blockquote><p>Объект по сути является просто ссылкой на структуру которая инкапсулируют и данные и специфичные для этого типа функции. Два разных объекта будут иметь две разных ссылки. Эта ссылка эквивалентна постоянному наблюдению за машиной. Изменение машины отменяет ссылку и изменяет лежащие в её основе данные. Как вы увидите дальше, в действительности мы не хотим этого, и объект предоставляет защиту от опасного прямого доступа. До сих пор вы можете сказать, что тоже самое вы можете сделать с указателями на структуры. Вы можете быть правы в том что касается C++, так как C++ структуры и классы очень похожи исключая видимость членов по умолчанию. В языке вроде Delphi объекты всегда находятся в куче, в то время как записи (record) могут находится в стеке и в куче. Границы между записями и объектами размыты, но только потому что сейчас у записей появилось больше специфичных для объектов функций. Есть большое отличие: на объекты мы ссылаемся через переменную объявленную как класс объекта <strong>или как класс одного одного из предков</strong>. Мы также можем ссылаться на объект через один (или больше) интерфейс которые поддерживает его класс. Это обеспечивает безопасный доступ к типу за ссылкой.</p><h2 id="объекты-хранят-данные-и-функции-вместе" tabindex="-1"><a class="header-anchor" href="#объекты-хранят-данные-и-функции-вместе" aria-hidden="true">#</a> Объекты хранят данные и функции вместе</h2><p>Что делает объект большим чем просто указатель на структуру данных в памяти? Это совмещение функциональности и данных близко друг к другу. Давайте вернёмся на парковку:</p><blockquote><p>Я: Что происходит когда вы поворачиваете ключ зажигания? Вы: Машина заводится Я: Как? Вы: Я не знаю, я делаю это поворачивая ключ. Я: И затем? Вы: Я включаю передачу, нажимаю на газ и еду? Я: Но как в действительности машина работает? Вы: Меня заботит только то что она работает.</p></blockquote><p>Внезапно наше различие становится ещё более ясным. Мы можем напрямую управлять машиной: повернуть ключ, включить передачу, нажать на газ. Если мы смоделируем это в процедурном стиле мы можем сделать процедуры для каждого действия с параметром — указателем на структуру данных &quot;машина&quot;. В случае ООЯП процедуры которые работают непосредственно на объекте (методы) легко найти и они прямо обявляются в обявлении класса (class definition) класса.</p><h2 id="объекты-позволяют-скрыть-внутреннюю-функциональность-и-приватные-данные" tabindex="-1"><a class="header-anchor" href="#объекты-позволяют-скрыть-внутреннюю-функциональность-и-приватные-данные" aria-hidden="true">#</a> Объекты позволяют скрыть внутреннюю функциональность и приватные данные</h2><p>Автомобиль скрывает свою деятельность под капотом, мы просто видим приборы и рычаги управления. Эта форма абстракции специально облегчается инкапсуляцией данных и функциональности в объекте. В отличии от этого, мы можем затратить много усилий чтобы спрятать функциональность в процедурных языках, потому, что процедуры должны иметь доступ к изкоуровневым операциям и данным нашей машны так как без них не получится провводить какие-то действия с машиной.</p><p>В C++ определение класс обычно находится в заголовочных файлах (<code>.h</code>, <code>.hpp</code>, <code>.hxx</code>), а реализация в файлах с кодом (<code>.c</code>, <code>.cpp</code>, <code>.cxx</code>). Также в Delphi, определение класса обычно находится в секции интерфейса модуля, а код методов находится в секции реализации. Другие модули, которые ссылаются на текущий модуль (через конструкцию <code>uses</code>) имеют доступ только к секции интерфейса текущего модуля. В Java\\C# определение и реализация класса объединены, но потребители класса имеют ограниченную видимость. Таким образом от C++ к Delphi и затем к C# мы видим постепенную уменьшение физического разделения интерфейса и реализации через файлы, но это не так важно как звучит. Это не влияет на видимость снаружи класса.</p><h2 id="объекты-предоставляют-права-доступа" tabindex="-1"><a class="header-anchor" href="#объекты-предоставляют-права-доступа" aria-hidden="true">#</a> Объекты предоставляют права доступа</h2><p>В большинстве объектно ориентированных языках есть концепция секций с разным уровнем доступа. В Delphi имеются следующие области видимости</p><ul><li>strict private</li><li>private</li><li>strict protected</li><li>protected</li><li>public</li><li>published</li></ul>',20),h=(0,r.Uk)("Подробнее в посте "),o={href:"https://way23.ru/%D0%BE%D0%B1%D0%BB%D0%B0%D1%81%D1%82%D0%B8-%D0%B2%D0%B8%D0%B4%D0%B8%D0%BC%D0%BE%D1%81%D1%82%D0%B8-%D1%8D%D0%BB%D0%B5%D0%BC%D0%B5%D0%BD%D1%82%D0%BE%D0%B2-%D0%BA%D0%BB%D0%B0%D1%81%D1%81%D0%BE%D0%B2-delp/",target:"_blank",rel:"noopener noreferrer"},u=(0,r.Uk)("Области видимости элементов классов Delphi"),B=(0,r.Uk)("."),b=(0,r.uE)('<p>Кроме секций доступ можно контролировать с помощью свойств. Свойства отображаются на поля и могут иметь отношения один к одному к полям, но также они позволяют проверять ошибки и контролировать доступ потребителя для чтения и записи значений в объект. Для примера, в нашем <code>TCircle</code> мы можем иметь иметь внутреннее свойство <code>FRadius</code> для предоставления радиуса и мы можем напрямую считывать значения поля через свойство, но установку значения свойства мы можем сделать через сеттер. В этом методе мы можем, например, обеспечить что радиус всегда положительный.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TArc = class\nprivate\n  FRadius: double;\n  procedure SetRadius(const AValue: double);\npublic\n  property Radius: double read FRadius write SetRadius;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><h2 id="в-итоге" tabindex="-1"><a class="header-anchor" href="#в-итоге" aria-hidden="true">#</a> В итоге</h2><p>Инкапсуляция организует код и контролирует доступ. Она позволяет нам ссылаться на группу связанных данных по ссылке и оперировать ими только через чётко обозначенные методы и свойства.</p>',4),g={render:function(e,a){const l=(0,r.up)("OutboundLink");return(0,r.wg)(),(0,r.iD)(r.HY,null,[(0,r._)("h1",n,[t,(0,r.Uk)(" "+(0,i.zw)(e.$frontmatter.title),1)]),(0,r._)("p",null,[d,(0,r._)("a",s,[p,(0,r.Wm)(l)]),c]),D,(0,r._)("p",null,[h,(0,r._)("a",o,[u,(0,r.Wm)(l)]),B]),b],64)}}}}]);