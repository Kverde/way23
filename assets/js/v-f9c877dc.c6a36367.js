"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[2250],{7957:(e,t,r)=>{r.r(t),r.d(t,{data:()=>n});const n={key:"v-f9c877dc",path:"/%D0%BF%D1%80%D0%B5%D0%BE%D0%B1%D1%80%D0%B0%D0%B7%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5-%D1%82%D0%B8%D0%BF%D0%BE%D0%B2-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BE%D0%B2-%D0%B2-delphi.html",title:"Преобразование типов объектов в Delphi",lang:"ru-RU",frontmatter:{title:"Преобразование типов объектов в Delphi",date:"2019-03-24",categories:["Delphi"],tags:["Delphi","совершенный-код"]},excerpt:"",headers:[],filePathRelative:"преобразование-типов-объектов-в-delphi.md",git:{updatedTime:1692859375e3}}},49702:(e,t,r)=>{r.r(t),r.d(t,{default:()=>E});var n=r(66252),s=r(3577);const a={id:"frontmatter-title",tabindex:"-1"},i=(0,n._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),o=(0,n.uE)("<p>Хочу рассмотреть один дискуссионный вопрос связанный с преобразованием типов. Сначала краткое введение. В Delphi существует два оператора <strong>is</strong> и <strong>as</strong>, связанных с преобразованием типов, и способ преобразования типа с помощью функции с именем типа (класса).</p><p>Оператор <strong>is</strong> используется для проверки типа, если объект соответствует указанному типу или является его наследником, то оператор возвращает <strong>True</strong>. В случае если в переменной <strong>nil</strong> то оператор возвращает <strong>False</strong>.</p><p>if Object is TButton then</p><p>Оператор <strong>as</strong> используется для преобразования типа. Если объект соответствует типу или наследнику, то он преобразуется, если нет то выдаётся исключение <strong>EInvalidCast</strong>. В случае если в переменной <strong>nil</strong>, то исключение не произойдёт, но, конечно, обратится к полям объекта не получится - будет другое исключение.</p><p>Существует второй способ преобразования типа переменной - просто оборачиваем её в функцию с именем нужного класса. В этом случае проверки на тип не происходит. Посмотреть различия в работе можно на следующем коде:</p><p>// На форме две кнопки и у них два обработчика, добавленные стандартным способом, больше в проекте ничего нет.</p><p>procedure TForm1.Button1Click(Sender: TObject); begin ShowMessage((Sender as TMaskEdit).Text); end;</p><p>procedure TForm1.Button2Click(Sender: TObject); begin ShowMessage(TMaskEdit(Sender).Text); end;</p><p>А вот и сам вопрос. Предположим мы делаем проверку на тип объекта и потом выполняем с ним какие-то действия. Какой вариант использовать предпочтительнее?</p><p>// На форме две кнопки и у них два обработчика, добавленные стандартным способом, больше в проекте ничего нет.</p><p>procedure TForm1.Button1Click(Sender: TObject); begin if Sender is TMaskEdit then ShowMessage((Sender as TMaskEdit).Text); end;</p><p>procedure TForm1.Button2Click(Sender: TObject); begin if Sender is TMaskEdit then ShowMessage(TMaskEdit(Sender).Text); end;</p><p>Некоторые моменты.</p><p>Оставим в стороне вопрос о контексте этого условия. Условие по типу это плохой вариант и их следует избегать. Но предположим, что есть необходимость именно в таком условии и выполнении действий с объектами после условия.</p><p>Также оставим в стороне вопрос о производительности. В данном случае не принципиально, что будет выполнятся быстрее и медленнее, сможет ли компилятор оптимизировать или нет.</p><p>В рассматриваемом вопросе интересует именно читаемость и идиоматичность таких конструкций для Delphi. Есть некоторые за и против двух вариантов.</p><p>Вариант с функцией короче (меньше символов) и содержит на одну конструкцию меньше, что делает его проще.</p><p>Второй аргумент - вариант с функцией более логичен, сначала проверяем тип, а потом уже используем объект с этим типом без дополнительной проверки. Если рассматривать псевдокод, то варианты выглядят так</p><p>Если Sender является TMaskEdit Покажи (Sender как TMaskEdit).Текст, но если Sender не является TMaskEdit выведи исключение</p><p>Если Sender является TMaskEdit Покажи (Sender как TMaskEdit).Текст</p>",20),p=(0,n.Uk)("С другой стороны, возможно, способ с функций больше подходит для преобразования простых типов, а для классов следует всегда использовать "),l=(0,n._)("strong",null,"as",-1),d=(0,n.Uk)(". В "),c={href:"http://docwiki.embarcadero.com/RADStudio/Rio/en/Expressions_(Delphi)#Variable_Typecasts",target:"_blank",rel:"noopener noreferrer"},D=(0,n.Uk)("документации"),u=(0,n.Uk)(' при описании преобразования типов указано "For information about casting class and interface types, see "The as Operator" in Class References and Interface References (Delphi).". Впрочем, эта предложение, никак не указывает и не намекает на предпочтительность оператора '),k=(0,n._)("strong",null,"as",-1),g=(0,n.Uk)("."),h=(0,n._)("p",null,[(0,n.Uk)("И ещё есть аспект надёжности, особенно в крупном проекте с участием большого количества разработчиков. В этом смысле преимущества у варианта с оператором "),(0,n._)("strong",null,"as"),(0,n.Uk)('. Например, если часть "(Sender as TMaskEdit).Text" будет скопирована в любой другой контекст, можно быть уверенным что объект будет нужного типа или код упадёт с исключением. Если же применяется вариант "TMaskEdit(Sender).Text" то может возникнуть неопределённое поведение. Это похоже на один из доводов в пользу отказа от '),(0,n._)("strong",null,"with"),(0,n.Uk)(".")],-1),T=(0,n._)("p",null,"Буду рад выслушать любые мысли по этому поводу.",-1),B=(0,n._)("p",null,"Ссылки на документацию",-1),f={href:"http://docwiki.embarcadero.com/RADStudio/Rio/en/Class_References",target:"_blank",rel:"noopener noreferrer"},S=(0,n.Uk)("Описание операторов is и as"),_={href:"http://docwiki.embarcadero.com/RADStudio/Rio/en/Expressions_(Delphi)#Variable_Typecasts",target:"_blank",rel:"noopener noreferrer"},b=(0,n.Uk)("Преобразование типа переменной"),E={render:function(e,t){const r=(0,n.up)("OutboundLink");return(0,n.wg)(),(0,n.iD)(n.HY,null,[(0,n._)("h1",a,[i,(0,n.Uk)(" "+(0,s.zw)(e.$frontmatter.title),1)]),o,(0,n._)("p",null,[p,l,d,(0,n._)("a",c,[D,(0,n.Wm)(r)]),u,k,g]),h,T,B,(0,n._)("ul",null,[(0,n._)("li",null,[(0,n._)("a",f,[S,(0,n.Wm)(r)])]),(0,n._)("li",null,[(0,n._)("a",_,[b,(0,n.Wm)(r)])])])],64)}}}}]);