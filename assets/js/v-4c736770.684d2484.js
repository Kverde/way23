"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[6710],{43193:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-4c736770",path:"/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-7.html",title:"Написание простого DSL компилятора на Delphi (7. Компилятор AST)",lang:"ru-RU",frontmatter:{title:"Написание простого DSL компилятора на Delphi (7. Компилятор AST)",date:"2019-06-11",categories:["Delphi"],tags:["Delphi","перевод","компиляторы"]},excerpt:"",headers:[],filePathRelative:"написание-простого-dsl-компилятора-на-delphi-7.md",git:{updatedTime:1692859375e3}}},84e3:(n,e,s)=>{s.r(e),s.d(e,{default:()=>F});var a=s(66252),r=s(3577);const l={id:"frontmatter-title",tabindex:"-1"},p=(0,a._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),i=(0,a.Uk)("Перевод поста "),t={href:"https://www.thedelphigeek.com/2017/11/writing-simple-dsl-compiler-with-delphi.html",target:"_blank",rel:"noopener noreferrer"},c=(0,a.Uk)("Writing a Simple DSL Compiler with Delphi (7. AST Compiler)"),b=(0,a.Uk)("."),m=(0,a.Uk)("Эта статья представляет собой описание компилятора AST используемого для проекта моего языка программирования. Если вы только начинаете читать эту серию, то я бы рекомендовал вам начать с "),o={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-0/",target:"_blank",rel:"noopener noreferrer"},u=(0,a.Uk)("этого поста"),d=(0,a.Uk)(". Как минимум вы должны прочитать предыдущий пост "),D={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-inte/",target:"_blank",rel:"noopener noreferrer"},g=(0,a.Uk)("Intermezzo"),x=(0,a.Uk)(" так как он разъясняет некоторые части компилятора которых я не касаюсь здесь."),B=(0,a.uE)('<p>В каркасе моего игрушечного компилятора, компилятор (или <code>codegen</code>, как он называется внутри) — часть кода которая реализует интерфейс <code>ISimpleDSLCodegen</code>. Этот интерфейс предоставляет только одну функцию, <code>Generate</code>, которая принимает абстрактное синтаксическое дерево и преобразует его в объект, который реализует интерфейс <code>ISimpleDSLProgram</code>, который позволяет вам вызывать любую функцию скомпилированной программы по имени.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TParameters = TArray;\n  TFunctionCall = reference to function (const parameters: TParameters): integer;\n  ISimpleDSLProgram = interface [&#39;{2B93BEE7-EF20-41F4-B599-4C28131D6655}&#39;]\n    function  Call(const functionName: string; const params: TParameters;       var return: integer): boolean;\n   end;\n\n  ISimpleDSLCodegen = interface [&#39;{C359C174-E324-4709-86EF-EE61AFE3B1FD}&#39;]\n    function Generate(const ast: ISimpleDSLAST;\n      var runnable: ISimpleDSLProgram): boolean;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Компилятор по умолчанию реализован классом <code>TSimpleDSLCodegen</code> в модуле <code>SimpleDSLCompiler.Compiler</code>. Методы в этом классе в основном занимаются чтением и пониманием AST пока код, фактически, создаётся в методах в модуле <code>SimpleDSLCompiler.Compiler.Codegen</code>.</p><p>Этот компилятор создаёт программу которая является интерфейсом класса <code>TSimpleDSLProgram</code> (также находящемся в <code>SimpleDSLCompiler.Compiler</code>).</p><p>Функционирование компилятора очень похоже на компилятор представленный в Intermezzo — с одним критичным отличием. Выражения в моём игрушечном языке могут использовать параметры функций как слагаемые. Поэтому вычислитель выражений должен иметь доступ к параметрам текущей функции.</p><p>История начинается в методе <code>TSimpleDSLCodegen.Generate</code> который для каждой функции в дереве сначала компилирует тело функции (<code>CompileBlock</code>) и затем генерирует функциональную обёртку для этого тела (<code>CodegenFunction</code>).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLCodegen.Generate(const ast: ISimpleDSLAST; var runnable:\n  ISimpleDSLProgram): boolean;\nvar\n  block      : TStatement;\n  i          : integer;\n  runnableInt: ISimpleDSLProgramEx;\nbegin\n  Result := false; //to keep compiler happy\n  FAST := ast;\n  runnable := TSimpleDSLProgram.Create;\n  runnableInt := runnable as ISimpleDSLProgramEx;\n  for i := 0 to ast.Functions.Count - 1 do begin\n    if not CompileBlock(ast.Functions[i].Body, block) then\n      Exit;\n    runnableInt.DeclareFunction(i, ast.Functions[i].Name,       CodegenFunction(block));\n  end;\n  Result := true;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>Давайте начнём с последней функции так как она даст нам больше контекста (каламбур, как вы увидите скоро).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  PExecContext = ^TExecContext;\n   TExecContext = record\n    Functions: TArray;\n  end;\n\n  TParameters = TArray;\n\nfunction CodegenFunction(const block: TStatement): TFunction;\nbegin\n  Result :=\n    function (execContext: PExecContext; const params: TParameters): integer\n    var\n      context: TContext;\n    begin\n      context.Exec := execContext;\n      context.Params := params;\n      context.Result := 0;\n      block(context);\n      Result := context.Result;\n    end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br></div></div>',9),C=(0,a._)("code",null,"CodegenFunction",-1),T=(0,a.Uk)(" создаёт основную обёртку в виде анонимного метода для текущей функции. Этот анонимный метод получит контекст выполнения, который позволит этой функции вызывать другие функции. Затем анонимный метод построит контекст функции который грубо соответствует стековому фрейму ("),h={href:"https://ru.wikipedia.org/wiki/%D0%A1%D1%82%D0%B5%D0%BA%D0%BE%D0%B2%D1%8B%D0%B9_%D0%BA%D0%B0%D0%B4%D1%80",target:"_blank",rel:"noopener noreferrer"},S=(0,a.Uk)("stack frame"),v=(0,a.Uk)(') производимому "нормальным" компилятором. Этот контекст хранит указатель на контекст выполнения и копию параметров (значений) переданных в функцию. Затем он вызывает '),f=(0,a._)("code",null,"block(context)",-1),E=(0,a.Uk)(" для выполнения переданного блока."),k=(0,a.uE)('<p>Спустимся на один уровень ниже... Функция <code>TSimpleDSLCodegen.CompileBlock</code> компилирует каждое выражение в блоке вызовом <code>CompileStatement</code> и затем вызывает <code>CodegenBlock</code> для обёртки скомпилированных выражений в блок.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CodegenBlock(const statements: TStatements): TStatement;\nbegin\n  Result :=\n    procedure (var context: TContext)\n    var\n      stmt: TStatement;\n    begin\n      for stmt in statements do\n        stmt(context);\n    end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Скомпилированный код, который реализует блок, снова является анонимным методом. Он принимает контекст (передаваемый анонимным методом реализующим функцию) и просто передаёт этот же контекст во все выражения в блоке.</p><p>Это продолжается и продолжается. Большая часть кода довольна скучна и предсказуема. Например, это метод который генерирует код для оператора <code>if</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CodegenIfStatement(const condition: TExpression; const thenBlock,\n  elseBlock: TStatement): TStatement;\nbegin\n  Result :=\n    procedure (var context: TContext)\n    begin\n      if condition(context) &lt;&gt; 0 then\n        thenBlock(context)\n      else\n        elseBlock(context);\n    end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>Вещи становятся интереснее как только мы хотим скомпилировать слагаемое. Слагаемое может представлять константу (целое число), параметр (названный <code>variable</code> в codegen так как в будущем может быть добавлена поддержка переменных) или вызовом функции.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLCodegen.CompileTerm(const astTerm: IASTTerm;   var codeTerm: TExpression): boolean;\nvar\n  termConst   : IASTTermConstant;\n  termFuncCall: IASTTermFunctionCall;\n  termVar     : IASTTermVariable;\nbegin\n  Result := true;\n  if Supports(astTerm, IASTTermConstant, termConst) then\n    codeTerm := CodegenConstant(termConst.Value)\n  else if Supports(astTerm, IASTTermVariable, termVar) then\n    codeTerm := CodegenVariable(termVar.VariableIdx)\n  else if Supports(astTerm, IASTTermFunctionCall, termFuncCall) then\n    Result := CompileFunctionCall(termFuncCall, codeTerm)\n  else\n    Result := SetError(&#39;*** Unexpected term&#39;);\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>Компиляция константы тривиальна. Нам просто нужна функция возвращающая эту константу.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CodegenConstant(value: integer): TExpression;\nbegin\n  Result :=\n    function (var context: TContext): integer\n    begin\n      Result := value;\n    end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Доступ к параметрам немного сложнее. AST содержит индекс этого параметра и мы просто должны применить его к свойству <code>Params</code> контекста.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CodegenVariable(varIndex: integer): TExpression;\nbegin\n  Result :=\n    function (var context: TContext): integer\n    begin\n      Result := context.Params[varIndex];\n    end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Генерация вызова функции немного более сложная. Она должна настроить массив параметров который будет передан в вызов функции, найти корректную функцию через контекст запуска и затем вызывать функцию.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CodegenFunctionCall(funcIndex: integer;   const params: TFuncCallParams): TExpression;\nbegin\n  Result :=\n    function (var context: TContext): integer\n    var\n      funcParams: TParameters;\n      iParam    : Integer;\n    begin\n      SetLength(funcParams, Length(params));\n      for iParam := Low(params) to High(params) do\n        funcParams[iParam] := params[iParam](context);\n      Result := context.Exec.Functions[funcIndex](context.Exec, funcParams);\n    end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>В конце компилятор производит большой анонимный метод, использующий внутри другие анонимные методы, и который при вызове возвращает результат.</p><p>Например, эта минимальная программа ...</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>inc(i) { return i+1 }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>... генерирует что-то похожее на следующее чудовище. В реальности код даже более странный так как он должен обрабатывать захваченные переменные.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function (execContext: PExecContext; const params: TParameters): integer\nvar\n  context: TContext;\nbegin\n  context.Exec := execContext;\n  context.Params := params;\n  context.Result := 0;\n (procedure (var context: TContext)\n  var\n    stmt: TStatement;\n  begin\n    for stmt in [\n                procedure (var context: TContext)\n                begin\n                  context.Result :=\n                   (function (var context: TContext): integer\n                    begin\n                      Result :=\n                       (function (var context: TContext): integer\n                        begin\n                          Result := context.Params[0];\n                        end)(context)\n                        +\n                       (function (var context: TContext): integer\n                        begin\n                          Result := 1;\n                        end)(context);\n                    end)(context);\n                end\n                ]\n    do\n      stmt(context);\n  end)(context);\n  Result := context.Result;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br></div></div><p>Он определённо не для слабонервных, но вы не должны смотреть скомпилированный код (конечно, исключая случая отладки компилятора).</p><p>Вы можете удивится скорости этого кода. Должен признать — не очень быстро. Я дам вам более точные цифры в следующей части этой серии которая будет описывать интерпретатор для этого языка.</p>',20),F={render:function(n,e){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[(0,a._)("h1",l,[p,(0,a.Uk)(" "+(0,r.zw)(n.$frontmatter.title),1)]),(0,a._)("p",null,[i,(0,a._)("a",t,[c,(0,a.Wm)(s)]),b]),(0,a._)("p",null,[m,(0,a._)("a",o,[u,(0,a.Wm)(s)]),d,(0,a._)("a",D,[g,(0,a.Wm)(s)]),x]),B,(0,a._)("p",null,[C,T,(0,a._)("a",h,[S,(0,a.Wm)(s)]),v,f,E]),k],64)}}}}]);