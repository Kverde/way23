"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[1445],{41750:(D,e,n)=>{n.r(e),n.d(e,{data:()=>B});const B={key:"v-64574022",path:"/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-0.html",title:"Написание простого DSL компилятора на Delphi (0. Введение)",lang:"ru-RU",frontmatter:{title:"Написание простого DSL компилятора на Delphi (0. Введение)",date:"2019-06-03",categories:["Delphi"],tags:["Delphi","перевод","компиляторы"]},excerpt:"",headers:[],filePathRelative:"написание-простого-dsl-компилятора-на-delphi-0.md",git:{updatedTime:1692859375e3}}},1862:(D,e,n)=>{n.r(e),n.d(e,{default:()=>q});var B=n(66252),r=n(3577);const l={id:"frontmatter-title",tabindex:"-1"},a=(0,B._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),t=(0,B.Uk)("Перевод поста "),s={href:"https://www.thedelphigeek.com/2017/08/writing-simple-dsl-compiler-with-delphi.html",target:"_blank",rel:"noopener noreferrer"},p=(0,B.Uk)("Writing a Simple DSL Compiler with Delphi (0. Introduction)"),i=(0,B.Uk)("Некоторое время назад я слушал подкаст Hanselminutes ("),o={href:"https://hanselminutes.com/586/you-should-write-an-interpreter-with-thorsten-ball",target:"_blank",rel:"noopener noreferrer"},u=(0,B.Uk)("YOU should write an interpreter with Thorsten Ball"),d=(0,B.Uk)(") где парень описал как он написал простой интерпретатор на языке Go. В действительности, меня не очень интересовало написание интерпретатора — я уже делал это однажды — но мысль закралась мне в голову. Я спросил себя смогу ли я сделать что-то лучше — написать компилятор (или что-то похожее на компилятор, как вы увидите дальше)."),h=(0,B.uE)('<p>То что я хотел сделать — это взять простой язык, распарить его, сгенерировать абстрактное синтаксическое дерево и затем конвертировать его в одну большую анонимную функцию вызывающую другие анонимные функции, которые вызывают другие анонимные функции и так далее. Это сложно объяснить, так что позвольте мне показать очень простой пример.</p><p>Скажем, у меня есть простоя программа написанная на моём языке которая складывает два числе вместе</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token function">add</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">return</span> a <span class="token operator">+</span> b\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Простой, С-подобный синтаксис. Не сложно угадать, что функция складывает два числа и возвращает результат.</p><p>Я хочу чтобы мой код конвертировал это в что-то похожее на это (и я здесь сильно упрощаю, в действительности код будет более сложный):</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CodegenAdd(a, b: integer): integer;\nbegin\n  Result := a + b;\nend;\n\nprog :=\n  function (params: TArray): integer\n  begin\n    Result := CodegenAdd(params[0], params[1]);\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Для запуска программы, я могу вызывать <code>prog([1,2])</code> и я получу 3 в результате.</p><p>Я называю это <em>компилятором</em> потому, что я получаю из него скомпилированную анонимную функцию (<code>prog</code>) которую в последующем я могу вызывать столько раз сколько захочу. Также я могу использовать разные параметры для каждого вызова. В тоже время, это компилятор для очень специфичной <em>архитектуры</em> — набор функций (как <code>CodegenAdd</code>) который в этом сценарии могут представляет очень специфичный <em>набор машинных инструкций</em>.</p><p>Теперь более понятно, почему я назвал мой компилятор &quot;что-то вроде компилятора&quot;. Он не компилирует программу в CPU-исполняемый формат, а использует очень специфичную <em>среду времени выполнения</em> — набор функций скомпилированных в Delphi программу и он не может быть сохранен как отдельно запускаемое приложение. За исключением всех ограничений, это мощная техника, запускаемый код быстрее чем простой интерпретатор того же языка. Но я захожу вперёд.</p><p>Эта статья просто введение в серию в которой я буду медленно презентовать мой проект. На данный момент запланированы следующие статьи:</p>',10),c={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-1/",target:"_blank",rel:"noopener noreferrer"},m=(0,B.Uk)("Язык"),b={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-2/",target:"_blank",rel:"noopener noreferrer"},E=(0,B.Uk)("Абстрактное синтаксическое дерево (AST)"),k={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-3/",target:"_blank",rel:"noopener noreferrer"},g=(0,B.Uk)("Токинизатор"),_={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-4/",target:"_blank",rel:"noopener noreferrer"},F=(0,B.Uk)("Парсер"),f={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-5/",target:"_blank",rel:"noopener noreferrer"},w=(0,B.Uk)("Фреймворк"),U={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-6/",target:"_blank",rel:"noopener noreferrer"},A=(0,B.Uk)("AST Dumper"),C={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-inte/",target:"_blank",rel:"noopener noreferrer"},y=(0,B.Uk)("Intermezzo"),W={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-7/",target:"_blank",rel:"noopener noreferrer"},v=(0,B.Uk)("Компилятор AST"),S=(0,B._)("li",null,"Интерпретатор AST",-1),T=(0,B._)("li",null,"Ускорение исполнения и расширение языка",-1),L=(0,B._)("li",null,"Ускорение интерпретатора",-1),x=(0,B.Uk)("Нетерпеливые могут найти весь код и демонстрационный проект на "),R={href:"https://github.com/gabr42/SimpleDSLCompiler",target:"_blank",rel:"noopener noreferrer"},z=(0,B.Uk)("GitHub"),H=(0,B.Uk)("."),q={render:function(D,e){const n=(0,B.up)("OutboundLink");return(0,B.wg)(),(0,B.iD)(B.HY,null,[(0,B._)("h1",l,[a,(0,B.Uk)(" "+(0,r.zw)(D.$frontmatter.title),1)]),(0,B._)("p",null,[t,(0,B._)("a",s,[p,(0,B.Wm)(n)])]),(0,B._)("p",null,[i,(0,B._)("a",o,[u,(0,B.Wm)(n)]),d]),h,(0,B._)("ol",null,[(0,B._)("li",null,[(0,B._)("a",c,[m,(0,B.Wm)(n)])]),(0,B._)("li",null,[(0,B._)("a",b,[E,(0,B.Wm)(n)])]),(0,B._)("li",null,[(0,B._)("a",k,[g,(0,B.Wm)(n)])]),(0,B._)("li",null,[(0,B._)("a",_,[F,(0,B.Wm)(n)])]),(0,B._)("li",null,[(0,B._)("a",f,[w,(0,B.Wm)(n)])]),(0,B._)("li",null,[(0,B._)("a",U,[A,(0,B.Wm)(n)]),(0,B._)("ul",null,[(0,B._)("li",null,[(0,B._)("a",C,[y,(0,B.Wm)(n)])])])]),(0,B._)("li",null,[(0,B._)("a",W,[v,(0,B.Wm)(n)])]),S,T,L]),(0,B._)("p",null,[x,(0,B._)("a",R,[z,(0,B.Wm)(n)]),H])],64)}}}}]);