"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[4935],{74332:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-56b07b2a",path:"/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-4.html",title:"Написание простого DSL компилятора на Delphi (4. Парсер)",lang:"ru-RU",frontmatter:{title:"Написание простого DSL компилятора на Delphi (4. Парсер)",date:"2019-06-07",categories:["Delphi"],tags:["Delphi","перевод","компиляторы"]},excerpt:"",headers:[],filePathRelative:"написание-простого-dsl-компилятора-на-delphi-4.md",git:{updatedTime:1692859375e3}}},90862:(n,e,s)=>{s.r(e),s.d(e,{default:()=>w});var a=s(66252),r=s(3577);const l={id:"frontmatter-title",tabindex:"-1"},p=(0,a._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),i=(0,a.Uk)("Перевод поста "),t={href:"https://www.thedelphigeek.com/2017/09/writing-simple-dsl-compiler-with-delphi_29.html",target:"_blank",rel:"noopener noreferrer"},b=(0,a.Uk)("Writing a Simple DSL Compiler with Delphi (4. Parser)"),c=(0,a.Uk)("."),o=(0,a.Uk)("Эта статья представляет собой описание парсера используемого для моего игрушечного языка программирования. Если вы только начинаете читать эту серию, то я бы рекомендовал вам начать с "),u={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-0/",target:"_blank",rel:"noopener noreferrer"},d=(0,a.Uk)("этого поста"),m=(0,a.Uk)("."),D=(0,a.Uk)("Пожалуйста, имейте в виду, что эта статья описывают начальную реализацию парсера. Если вы хотите просматривать код во время чтения статьи, убедитесь, что вы переключились на ветку "),k={href:"https://github.com/gabr42/SimpleDSLCompiler/tree/dsl_v1",target:"_blank",rel:"noopener noreferrer"},B=(0,a.Uk)("dsl_v1"),h=(0,a.Uk)("."),f=(0,a.Uk)('После перерыва я вернулся к серии про мой "игрушечный компилятор". Сейчас я опишу работу парсера — части кода которая читает входной поток (обычно в форме '),g={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-3/",target:"_blank",rel:"noopener noreferrer"},F=(0,a.Uk)("токенов"),T=(0,a.Uk)(") и генерирует внутреннее представление программы (в моём случае "),S={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-2/",target:"_blank",rel:"noopener noreferrer"},E=(0,a.Uk)("абстрактное синтаксическое дерево"),v=(0,a.Uk)(")."),L=(0,a.Uk)("Цель моего проекта была в изучении шагов компиляции и парсер был просто обязательным злом с которым я должен был иметь дело. Вот почему он написан в довольно примитивной форме, без использования улучшений как "),P={href:"http://journal.stuffwithstuff.com/2011/03/19/pratt-parsers-expression-parsing-made-easy/",target:"_blank",rel:"noopener noreferrer"},x=(0,a.Uk)("Pratt parser"),I=(0,a.Uk)("."),_=(0,a.uE)('<p>Мой парсер представлен как очень простой интерфейс. Он будет принимать код для разбора (как строку), ссылку на токинизатор которые должен использоваться для чтения входного потока и ссылку на корневой элемент результирующего AST. Функция вернёт False если разбор не удастся, в этом случае вызывающая сторона может преобразовать интерфейс парсера к <code>ISimpleDSLErrorInfo</code> для получения большей информации об ошибке.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  ISimpleDSLParser = interface [&#39;{73F3CBB3-3DEF-4573-B079-7EFB00631560}&#39;]\n    function Parse(const code: string; const tokenizer: ISimpleDSLTokenizer;\n      const ast: ISimpleDSLAST): boolean;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Так как программа на моём языке содержит только функции, то реализация функции <code>Parse</code> очень простая. Она заполняет несколько полей чтобы любая часть парсера имела доступ до соответствующей информации, инициализирует буфер предварительного просмотра (<code>FLookaheadIdent</code>) и разбирает функцию за функцией пока разбор не будет ошибки или токинезатор не сообщит что он достиг конца кода.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLParser.Parse(const code: string;   const tokenizer: ISimpleDSLTokenizer;\n  const ast: ISimpleDSLAST): boolean;\nbegin\n  Result := false;\n  FTokenizer := tokenizer;\n  FAST := ast;\n  FLookaheadIdent := #0;\n\n  tokenizer.Initialize(code);\n  while not tokenizer.IsAtEnd do\n    if not ParseFunction then\n      Exit;\n\n  Result := true;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Я не собираюсь показывать весь код парсера в этой короткой статье, только метод <code>ParseFunction</code>. Он ожидает найти идентификатор (название функции), с последующей левой круглой скобкой, с последующим, возможно пустым, списком разделённым запятыми идентификаторов (параметры функции), с последующей круглой закрывающейся скобкой и последующим блоком (тело функции).</p><p><code>ParseFunction</code> сначала берет идентификатор (название функции). Затем создаёт запись в глобальной таблице функций потому что она может нам понадобится в других частях парсера если функция рекурсивно вызывает себя. По этой же причине она также будет сохранять интерфейс элемента AST функции в <code>FContext.CurrentFunc</code>.</p><p>Затем она проверяет токен <code>tkLeftParen</code>. Если он присутствует, она войдёт в цикл с поиском идентификаторов (названий параметров) либо закрывающей скобки (конец списка параметров) и сохранит все имена параметров в AST (<code>func.ParamNames.Add</code>).</p><p>Если всё хорошо, она вызовет <code>ParseBlock</code> для разбора тела функции и сохранит результат в AST (<code>func.Body := block</code>).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLParser.ParseFunction: boolean;\nvar\n  block   : IASTBlock;\n  expected: TTokenKinds;\n  func    : IASTFunction;\n  funcName: string;\n  ident   : string;\n  token   : TTokenKind;\nbegin\n  Result := false;\n\n  /// function = identifier &quot;(&quot; [ identifier { &quot;,&quot; identifier } ] &quot;)&quot; block\n\n  // function name\n  if not FetchToken([tkIdent], funcName, token) then\n    Exit(token = tkEOF);\n\n  func := AST.CreateFunction;\n  func.Name := funcName;\n\n  // we might need this function in the global table for recursive calls\n  AST.Functions.Add(func);\n\n  FContext.CurrentFunc := func;\n  try\n\n    // &quot;(&quot;\n    if not FetchToken([tkLeftParen]) then\n      Exit;\n\n    // parameter list, including &quot;)&quot;\n    expected := [tkIdent, tkRightParen];\n    repeat\n      if not FetchToken(expected, ident, token) then\n        Exit;\n      if token = tkRightParen then\n        break //repeat\n      else if token = tkIdent then begin\n        func.ParamNames.Add(ident);\n        expected := expected - [tkIdent] + [tkComma, tkRightParen];\n      end\n      else if token = tkComma then\n        expected := expected + [tkIdent] - [tkComma, tkRightParen]\n      else begin\n        LastError := &#39;Internal error in ParseFunction&#39;;\n        Exit;\n      end;\n    until false;\n\n    // function body\n    if not ParseBlock(block) then\n      Exit;\n\n    func.Body := block;\n    Result := true;\n  finally\n    FContext.CurrentFunc := nil;\n  end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br></div></div><p>Токены всегда выбираются функцией <code>FetchToken</code> которая принимает список допустимых токенов, пропуская все пробелы и возвращает найденную пару токен\\идентификатор (или набор информации об ошибке включая положение в коде если встретился ошибочный токен).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLParser.FetchToken(allowed: TTokenKinds; var ident: string;\n  var token: TTokenKind): boolean;\nvar\n  loc: TPoint;\nbegin\n  Result := false;\n  while GetToken(token, ident) do\n    if token in allowed then\n      Exit(true)\n    else if token = tkWhitespace then\n      // do nothing\n    else begin\n      loc := FTokenizer.CurrentLocation;\n      LastError := Format(&#39;Invalid syntax in line %d, character %d&#39;,         [loc.X, loc.Y]);\n      Exit;\n    end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>Так же как токинезатор, парсер использует подход &quot;помести назад&quot; (push back). Когда он обнаруживает что прочитал лишний токен, он может поместить его обратно вызовом <code>PushBack</code>. Функция <code>GetToken</code> сначала смотрит в этот буфер и вызывает <code>tokenizer.GetToken</code> если буфер пустой.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TSimpleDSLParser.PushBack(token: TTokenKind; const ident: string);\nbegin\n  Assert(FLookaheadIdent = #0, &#39;TSimpleDSLParser: Lookahead buffer is not empty&#39;);\n  FLookaheadToken := token;\n  FLookaheadIdent := ident;\nend;\n\nfunction TSimpleDSLParser.GetToken(var token: TTokenKind; var ident: string): boolean;\nbegin\n  if FLookaheadIdent &lt;&gt; #0 then begin\n    token := FLookaheadToken;\n    ident := FLookaheadIdent;\n    FLookaheadIdent := #0;\n    Result := true;\n  end\n  else\n    Result := FTokenizer.GetToken(token, ident);\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>Как вы можете видеть, парсер действительно очень скучный кусок кода, следующий подходу &quot;это ожидаемый токен, какой следующий?&quot;. Конечно, жизнь становится сложнее когда имеешь дело в более сложным синтаксисом, в котором парсер иногда не может точно решить по какому пути следовать и должен пробовать несколько вариантов. Но это тема для отдельного поста.</p>',14),w={render:function(n,e){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[(0,a._)("h1",l,[p,(0,a.Uk)(" "+(0,r.zw)(n.$frontmatter.title),1)]),(0,a._)("p",null,[i,(0,a._)("a",t,[b,(0,a.Wm)(s)]),c]),(0,a._)("p",null,[o,(0,a._)("a",u,[d,(0,a.Wm)(s)]),m]),(0,a._)("p",null,[D,(0,a._)("a",k,[B,(0,a.Wm)(s)]),h]),(0,a._)("p",null,[f,(0,a._)("a",g,[F,(0,a.Wm)(s)]),T,(0,a._)("a",S,[E,(0,a.Wm)(s)]),v]),(0,a._)("p",null,[L,(0,a._)("a",P,[x,(0,a.Wm)(s)]),I]),_],64)}}}}]);