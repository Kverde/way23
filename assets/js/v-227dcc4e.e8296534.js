"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[637],{47296:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-227dcc4e",path:"/%D0%BF%D1%80%D0%B5%D0%B4%D0%B2%D0%B0%D1%80%D0%B8%D1%82%D0%B5%D0%BB%D1%8C%D0%BD%D0%BE%D0%B5-%D0%BE%D0%B1%D1%8A%D1%8F%D0%B2%D0%BB%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B7%D0%B0%D0%BF%D0%B8%D1%81%D0%B5%D0%B9-reco.html",title:"Предварительное объявление записей (record) в Delphi",lang:"ru-RU",frontmatter:{title:"Предварительное объявление записей (record) в Delphi",date:"2019-05-09",categories:["Delphi"],tags:["Delphi","перевод"]},excerpt:"",headers:[],filePathRelative:"предварительное-объявление-записей-reco.md",git:{updatedTime:1692859375e3}}},63202:(n,e,s)=>{s.r(e),s.d(e,{default:()=>t});var a=s(66252),r=s(3577);const l={id:"frontmatter-title",tabindex:"-1"},p=(0,a._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),c=(0,a.Uk)("Вольный перевод поста "),i={href:"https://www.thedelphigeek.com/2017/03/forward-record-declaration.html",target:"_blank",rel:"noopener noreferrer"},b=(0,a.Uk)("Forward record declaration"),d=(0,a.Uk)("."),u=(0,a.uE)('<p>Предварительная объявление не новая концепция. Она уже присутствовала в оригинальном Паскале Вирта, где она позволяла программистам делать только одну вещь — вызывать процедуру A из процедуры B и вызывать процедуру B из процедуры A. В те времена не было интерфейсов, классов, модулей, только процедуры и функции. Вот пример</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure ProcA; forward;\n\nprocedure ProcB;\nbegin\n  ProcA;\nend;\n\nprocedure ProcA;\nbegin\n  ProcB;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Более знакомая современная концепция — предварительное объявление для классов и интерфейсов.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TClassA = class;\n\n  TClassB = class\n    ObjA: TClassA;\n  end;\n\n  TClassA = class\n    ObjB: TClassB;\n  end;\n\n  IIntfA = interface;\n\n  IIntfB = interface\n    function Other: IIntfA;\n  end;\n\n  IIntfA = interface\n    function Other: IIntfB;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>В тоже время в Object Pascal нет концепции предварительного объявления записей. Следующий код не компилируется</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TRecA = record;\n\n  TRecB = record\n    function Other: TRecA;\n  end;\n\n  TRecA = record\n    function Other: TRecB;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Существует трюк который позволяет достичь аналогичной функциональности с помощью другого синтаксического сахара - record helpers. Мы можем удалить объявление <code>TRecB.Other</code> из <code>TRecB</code> и потом снова добавить его через хелпер для <code>TRecB</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TRecB = record\n  end;\n\n  TRecA = record\n    function Other: TRecB;\n  end;\n\n  TRecBHelper = record helper for TRecB\n    function Other: TRecA;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div><p>Но помните, что это решение менее стабильно: другой код может скрыть функционал <code>TRecBHelper</code> введя свой собственный хелпер для <code>TRecB</code>. (противная особенность языка которая действительно должна быть исправлена уже давно)</p>',9),t={render:function(n,e){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[(0,a._)("h1",l,[p,(0,a.Uk)(" "+(0,r.zw)(n.$frontmatter.title),1)]),(0,a._)("p",null,[c,(0,a._)("a",i,[b,(0,a.Wm)(s)]),d]),u],64)}}}}]);