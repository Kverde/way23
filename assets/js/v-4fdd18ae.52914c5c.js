"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[6497],{87633:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-4fdd18ae",path:"/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-6.html",title:"Написание простого DSL компилятора на Delphi (6. Дамп AST)",lang:"ru-RU",frontmatter:{title:"Написание простого DSL компилятора на Delphi (6. Дамп AST)",date:"2019-06-09",categories:["Delphi"],tags:["Delphi","перевод","компиляторы"]},excerpt:"",headers:[],filePathRelative:"написание-простого-dsl-компилятора-на-delphi-6.md",git:{updatedTime:1692859375e3}}},70376:(n,e,s)=>{s.r(e),s.d(e,{default:()=>Y});var a=s(66252),r=s(3577);const l={id:"frontmatter-title",tabindex:"-1"},p=(0,a._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),i=(0,a.Uk)("Перевод поста "),c={href:"https://www.thedelphigeek.com/2017/10/writing-simple-dsl-compiler-with-delphi_14.html",target:"_blank",rel:"noopener noreferrer"},t=(0,a.Uk)("Writing a Simple DSL Compiler with Delphi (6. AST Dumper)"),D=(0,a.Uk)("."),u=(0,a.Uk)("Эта статья представляет описание инструмента для тестирования моего игрушечного языка программирования. Если вы только начинаете читать эту серию, то я бы рекомендовал вам начать с "),o={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-0/",target:"_blank",rel:"noopener noreferrer"},b=(0,a.Uk)("этого поста"),d=(0,a.Uk)("."),m=(0,a.Uk)("Пожалуйста, имейте в виду, что эта статья описывают начальную реализацию парсера. Если вы хотите просматривать код во время чтения статьи, убедитесь, что вы переключились на ветку "),B={href:"https://github.com/gabr42/SimpleDSLCompiler/tree/dsl_v1",target:"_blank",rel:"noopener noreferrer"},g=(0,a.Uk)("dsl_v1"),h=(0,a.Uk)("."),k=(0,a.Uk)("Теперь, когда мы имеем работающий "),S={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-3/",target:"_blank",rel:"noopener noreferrer"},f=(0,a.Uk)("токинезатор"),F=(0,a.Uk)(" и "),T={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-4/",target:"_blank",rel:"noopener noreferrer"},v=(0,a.Uk)("парсер"),E=(0,a.Uk)(" генерирующие на выходе "),x={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-2/",target:"_blank",rel:"noopener noreferrer"},C=(0,a.Uk)("AST"),_=(0,a.Uk)(", мы можем начать работать над компилятором. Тем не менее, было бы отлично проверить корректность выходных данных парсера. Или по другому — нам нужны модульные тесты."),U=(0,a._)("p",null,"Тем не менее, написание модульных тестов для древовидных структур очень утомительная операция. В следующем посту я покажу тест для дерева в котором только пять листьев и это уже будет процесс который лучше пропустить. К счастью, мы можем сделать что-то более весёлое — мы можем написать код, который воссоздаст оригинальную программу из AST.",-1),L=(0,a.Uk)("Чтобы сделать это, мы напишем генератор кода который вместо машинного кода генерирует исходную программу. Мы можем сделать просто поместив новую фабрику "),A=(0,a._)("code",null,"codegen",-1),w=(0,a.Uk)(" в гибкий "),y={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-5/",target:"_blank",rel:"noopener noreferrer"},W=(0,a.Uk)("каркас компилятора"),I=(0,a.Uk)("."),P=(0,a.uE)('<div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>sl := TStringList.Create;\ntry\n  compiler := CreateSimpleDSLCompiler;\n  compiler.CodegenFactory := \n    function: ISimpleDSLCodegen \n    begin \n      Result := CreateSimpleDSLCodegenDump(sl); \n    end;\n  compiler.Compile(CMultiProcCode);\n  Writeln(sl.Text);\nfinally FreeAndNil(sl); end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br></div></div>',1),R=(0,a._)("code",null,"codegen",-1),q=(0,a.Uk)(" будет сохранять результирующую программу в список строк "),N=(0,a._)("code",null,"sl",-1),G=(0,a.Uk)(", который мы можем передать в анонимную процедуру ("),M=(0,a._)("code",null,"CodegenFactory",-1),J=(0,a.Uk)(") из-за полезного "),O={href:"http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Anonymous_Methods_in_Delphi#Variable_Binding_Mechanism",target:"_blank",rel:"noopener noreferrer"},z=(0,a.Uk)("захвата переменной"),H=(0,a.Uk)("."),V=(0,a.uE)('<p>Наш генератор кода — <code>TSimpleDSLCodegenDump</code> должен реализовывать интерфейс <code>ISimpleDSLCodegen</code> содержащий одну функцию — <code>Generate</code>. Эта функция берет AST и возвращает что-то запускаемое — <code>ISimpleDSLProgram</code>. Поскольку наш код не знает как создавать запускаемую программу, он будет возвращать <code>nil</code> в этом параметре.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  ISimpleDSLCodegen = interface [&#39;{C359C174-E324-4709-86EF-EE61AFE3B1FD}&#39;]\n    function Generate(const ast: ISimpleDSLAST; var runnable: ISimpleDSLProgram): boolean;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p>Полезные данные будут сохранены в список строк (<code>TStringList</code>) который передан в конструктор.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>constructor TSimpleDSLCodegenDump.Create(dump: TStringList);\nbegin\n  inherited Create;\n  FDump := dump;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Основная функция генерации кода сохраняет ссылку на AST в поле так что мы имеем доступ к нему из всех методов и затем восстаёт исходный код функция за функцией вызовами <code>DumpFunction</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLCodegenDump.Generate(const ast: ISimpleDSLAST;\n  var runnable: ISimpleDSLProgram): boolean;\nvar\n  i: integer;\nbegin\n  FErrors := false;\n  FAST := ast;\n  for i := 0 to ast.Functions.Count - 1 do begin\n    if i &gt; 0 then begin\n      WritelnText;\n      WritelnText;\n    end;\n    DumpFunction(ast.Functions[i]);\n  end;\n  FDump.Text := FText;\n  Result := not FErrors;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>Код программы собирается в поле <code>FText: string</code>. Два вспомогательных метода <code>WritelnText</code> используются для добавления данных в это поле.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TSimpleDSLCodegenDump.WritelnText(const s: string);\nbegin\n  WriteText(s);\n  WriteText(#13#10);\nend;\n\nprocedure TSimpleDSLCodegenDump.WriteText(const s: string);\nbegin\n  FText := FText + s;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Я покажу только две части этого &quot;генератора кода&quot; так как он довольно скучен. Как первый пример, эта функция записывает исходный код одной функции.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TSimpleDSLCodegenDump.DumpFunction(const func: TASTFunction);\nbegin\n  FCurrentFunc := func;\n  WriteText(Format(&#39;%s(%s) &#39;, [func.Name, &#39;&#39;.Join(&#39;,&#39;, func.ParamNames.ToArray)]));\n  DumpBlock(&#39;&#39;, func.Body);\n  FCurrentFunc := nil;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Ссылка на текущую функцию сохраняется снаружи так как она нужна нам в методе который записывает название переменной (не показан здесь). Затем мы записываем название функции, с последующим списком параметров. Хелпер <code>Join</code> для строк соединяет параметры в одну строку с разделителем в виде запятой. В конце мы вызываем <code>DumpBlock</code> для записи тела функции.</p><p>Во втором примере, метод <code>DumpExpression</code>, записывает выражение. Он вызывает <code>DumpTerm</code> для записи первого слагаемого, записывает оператор (если он есть) и записывает второе слагаемое.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TSimpleDSLCodegenDump.DumpExpression(const expr: TASTExpression);\nbegin\n  DumpTerm(expr.Term1);\n  case expr.BinaryOp of\n    opNone:        Exit;\n    opAdd:         WriteText(&#39; + &#39;);\n    opSubtract:    WriteText(&#39; - &#39;);\n    opCompareLess: WriteText(&#39; &lt; &#39;);\n    else begin\n      WritelnText(&#39;*** Unexpected operator&#39;);\n      FErrors := true;\n    end;\n  end;\n  DumpTerm(expr.Term2);\nend\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Если мы запустим этот &quot;генератор кода&quot; на простой программе вычисляющей i-тое число Фибоначчи, то...</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>&#39;fib(i) {                          &#39;#13#10 +\n&#39;  if i &lt; 3 {                      &#39;#13#10 +\n&#39;    return 1                      &#39;#13#10 +\n&#39;  } else {                        &#39;#13#10 +\n&#39;    return fib(i-2) + fib(i-1)    &#39;#13#10 +\n&#39;  }                               &#39;#13#10 +\n&#39;}                                 &#39; \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>...мы увидим что результат довольно близок к оригиналу</p><div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token function">fib</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">3</span>  <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token number">1</span>\n  <span class="token punctuation">}</span>  <span class="token keyword">else</span>  <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>i <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Разделители немного отличаются, но это не имеет значения так как мой игрушечный язык игнорирует пробельные символы. Это даёт нам уверенность что AST действительно правильно сгенерированно (как минимум в некоторых случаях). Чтобы быть более уверенными в правильной работе парсера мы могли бы написать больше тестов... или мы можем просто поиграть с компилятором, написать больше программ и проверить что они работают корректно. Однако, чтобы это сделать нам нужен сам компилятор.</p>',18),Y={render:function(n,e){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[(0,a._)("h1",l,[p,(0,a.Uk)(" "+(0,r.zw)(n.$frontmatter.title),1)]),(0,a._)("p",null,[i,(0,a._)("a",c,[t,(0,a.Wm)(s)]),D]),(0,a._)("p",null,[u,(0,a._)("a",o,[b,(0,a.Wm)(s)]),d]),(0,a._)("p",null,[m,(0,a._)("a",B,[g,(0,a.Wm)(s)]),h]),(0,a._)("p",null,[k,(0,a._)("a",S,[f,(0,a.Wm)(s)]),F,(0,a._)("a",T,[v,(0,a.Wm)(s)]),E,(0,a._)("a",x,[C,(0,a.Wm)(s)]),_]),U,(0,a._)("p",null,[L,A,w,(0,a._)("a",y,[W,(0,a.Wm)(s)]),I]),P,(0,a._)("p",null,[R,q,N,G,M,J,(0,a._)("a",O,[z,(0,a.Wm)(s)]),H]),V],64)}}}}]);