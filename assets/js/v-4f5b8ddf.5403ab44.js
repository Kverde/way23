"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[5867],{82026:(n,s,a)=>{a.r(s),a.d(s,{data:()=>e});const e={key:"v-4f5b8ddf",path:"/%D0%BF%D1%80%D0%B8%D0%BC%D0%B5%D1%80%D1%8B-%D0%BF%D0%BE%D1%80%D0%BE%D0%B6%D0%B4%D0%B0%D1%8E%D1%89%D0%B8%D1%85-%D0%BF%D0%B0%D1%82%D1%82%D0%B5%D1%80%D0%BD%D0%BE%D0%B2-%D0%B8%D0%B7-%D0%B1%D0%B0%D0%BD.html",title:"Примеры порождающих паттернов из Банды четырёх (GoF) на Delphi",lang:"ru-RU",frontmatter:{title:"Примеры порождающих паттернов из Банды четырёх (GoF) на Delphi",date:"2019-04-16",categories:["Delphi"],tags:["Delphi","паттерны","совершенный-код","перевод"]},excerpt:"",headers:[{level:3,title:"Абстрактная фабрика (Abstract Factory)",slug:"абстрактная-фабрика-abstract-factory",children:[]},{level:3,title:"Сборщик (Builder)",slug:"сборщик-builder",children:[]},{level:3,title:"Фабричный метод (Factory Method)",slug:"фабричныи-метод-factory-method",children:[]},{level:3,title:"Одиночка (Singleton)",slug:"одиночка-singleton",children:[]},{level:3,title:"Прототип (Prototype)",slug:"прототип-prototype",children:[]}],filePathRelative:"примеры-порождающих-паттернов-из-бан.md",git:{updatedTime:1692859375e3}}},70438:(n,s,a)=>{a.r(s),a.d(s,{default:()=>t});var e=a(66252),r=a(3577);const l={id:"frontmatter-title",tabindex:"-1"},p=(0,e._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),b=(0,e.Uk)("Вольный перевод статьи "),c={href:"https://schellingerhout.github.io/design%20patterns/design-patterns-creational-delphi/",target:"_blank",rel:"noopener noreferrer"},i=(0,e.Uk)("Gang-of-Four Creational Design Pattern Examples in Delphi"),u=(0,e.uE)('<p>Специализированная для Delphi версия Порождающих паттернов из книги “Design Patterns: Elements of Reusable Object-Oriented Software”.</p><h3 id="абстрактная-фабрика-abstract-factory" tabindex="-1"><a class="header-anchor" href="#абстрактная-фабрика-abstract-factory" aria-hidden="true">#</a> Абстрактная фабрика (Abstract Factory)</h3><p>Абстрактная фабрика это класс который создаёт компонент и возвращает его в виде базового (абстрактного) типа. Потребитель (код который использует фабрику) не видит реализацию ни фабрики, ни объектов которые она производит, а работает только с базовыми типами.</p><p>В этом примере используются интерфейсы вместо абстрактных классов, которые используются в примерах в книге. Любое количество конкретных классов могут реализовывать интерфейс фабрики.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>unit IntfMazeFactory;\n\ninterface\nuses\n  system.generics.collections;\n\ntype\n\nIMaze = interface\n // Определение не важно для примера\nend;\n\nIWall = interface\n // Определение не важно для примера\nend;\n\nIRoom = interface\n // Определение не важно для примера\nend;\n\nIDoor = interface\n // Определение не важно для примера\nend;\n\nIMazeFactory = interface\n  function MakeMaze: IMaze;\n  function MakeWall: IWall;\n  function MakeRoom(ANumber: integer): TArray&lt;IRoom&gt;;\n  function MakeDoor(AFromRoom, AToRoom: IRoom): IDoor;  \nend;\n\n// Мы можем использовать фабрику как параметр, например\n//   MazeGame.CreateMaze(AFactory);\n// MazeGame может создать лабиринт не привязываясь \n// к конкретной реализации фабрики или тем более \n// к конкретным реализациям объектов которые она производит\n\nimplementation\n\nend.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br></div></div><h3 id="сборщик-builder" tabindex="-1"><a class="header-anchor" href="#сборщик-builder" aria-hidden="true">#</a> Сборщик (Builder)</h3><p>Сборщик похож на Абстрактную фабрику, но предоставляет потребителю более высокий уровень абстракции. Фабрика предоставляет методы для создания отдельных элементов, а Сборщик собирает готовый продукт. Вид продукта и его состав может определятся через параметры.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>unit IntfMazeBuilder;\n\ninterface\n\ntype\n\nIMazeBuilder = interface\n  procedure BuildMaze;\n  procedure BuildRoom(ANumber: integer);\n  procedure BuildDoor(AFromRoomIndex, AToRoomIndex: integer); \n\n  function GetMaze: IMaze; \nend;\n\n// Сборщик также можно передавать в виде параметра \n//   LMaze := MazeGame.CreateMaze(ABuilder);\n// MazeGame также как и с фабрикой не привязывается к конкретной \n// реализации объектов лабиринта. Отличия от фабрики в том что\n// потребитель (MazeGame) может даже не знать о \n// блоках, порядке и связях между частями лабиринта\n\nimplementation\n\nend.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><h3 id="фабричныи-метод-factory-method" tabindex="-1"><a class="header-anchor" href="#фабричныи-метод-factory-method" aria-hidden="true">#</a> Фабричный метод (Factory Method)</h3><p>Фабричный метод это виртуальный метод, создающий продукты. Он может быть переопределён для расширения производимого набора классов.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>unit IntfFactoryMethod;\n\ninterface\n\ntype\n\nIProduct = interface\n // Определение не важно для примера\nend;\n\nTAbstractProductCreator = class abstract\npublic\n  function CreateProduct(AProductID: integer): IProduct; virtual;  \nend;\n\n// Шаблон проектирования действительно строится на основе одного метода.\n// Метод которые создаёт продукты должен быть виртуальным \n// и может быть переопределён потомками.\n// В методе может быть заложена логика для создания некоторых видов объектов по умолчанию. \n// В дальнейшем эта логика расширяется в потомках. \n// Обработка вызова, при создании методом объекта, идёт обычным путём \n// по иерархии наследования от потомков к предкам.\n\nimplementation\n\nuses    \n    ProductTags; // Предполагаем что идентификаторы продуктов определены здесь\n\nType\n\nTBaseProductA = class(TInterfacedObnject, IProduct)\n // Определение не важно для примера\nend;\n\nTBaseProductB = class(TInterfacedObnject, IProduct)\n // Определение не важно для примера\nend;\n\nfunction TAbstractProductCreator.CreateProduct(AProductID: integer): IProduct;\nbegin\n    // Потомки должны добавлять свои случаи и проваливаться в наследуемый метод\n   Case AProductID of \n     ProductTags.BaseProductA:\n        result := TBaseProductA.Create;\n     ProductTags.BaseProductB:\n        result := TBaseProductB.Create;\n    else\n        raise EProductIDUnkownException.Create;\n   end;\nend;\n\nend.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br></div></div><p>Мы можем переопределить метод и расширить реализацию. Более конкретные реализации фабрики могут добавлять любое количество новых продуктов, переопределять создание продуктов или прятать их.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>unit ConcreateFactoryMethod;\n\ninterface\nuses\n    intfFactoryMethod;\n\ntype\n\nTConcreteProductCreator = class(TAbstractProductCreator)\npublic\n  function CreateProduct(AProductID: integer): IProduct; override;  \nend;\n\n// Фабричный метод, создающий продукты, виртуальный и может быть переопределён \n\nimplementation\n\nuses    \n    ProductTags; // Предполагаем что идентификаторы продуктов определены здесь\n\nType\n\nTAdvancedProductX = class(TInterfacedObnject, IProduct)\n // Определение не важно для примера\nend;\n\nTAdvancedProductY = class(TProductA)\n // Определение не важно для примера\nend;\n\nfunction TConcreteProductCreator.CreateProduct(AProductID: integer): IProduct;\nbegin\n   Case AProductID of\n\n     ProductTags.AdvancedProductX:\n        result := TAdvancedProductX.Create;\n     ProdcutTags.BaseProductA,  ProductTags.AdvancedProductY: // Мы можем скрыть некоторые виды продуктов или перезаписать их\n        result := TAdvancedProductY.Create;\n    else\n      result := inherited;\n   end;\nend;\n\nend.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br></div></div><h3 id="одиночка-singleton" tabindex="-1"><a class="header-anchor" href="#одиночка-singleton" aria-hidden="true">#</a> Одиночка (Singleton)</h3><p>Я редко реализую этот паттерн и предпочитаю чистый абстрактный класс с классовыми свойствами и методами. Этот паттерн особенно сложно реализуется в Delphi потому, что всегда есть конструктор унаследованный от TObject. Так что не получается реализовать паттерн, так как описано в книге. Единственный путь - спрятать конструктор и предоставлять интерфейс вместо класса.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>unit SingletonMazeFactory;\n\ninterface\nuses\n  IntfMazeFactory;\n\nFunction MazeFactoryInstance: IMazeFactory;\n\nimplementation\n\ntype\n\nTMazeFactory = class(TInterfacedObject, IMazeFactory)\nprivate \n\nprivate\n  class var FInstance: IMazeFactory; \n\n  class function GetInstance: IMazeFactory; static;\npublic\n  Constructor Create;\n\n  function MakeMaze: IMaze;\n  function MakeWall: IWall;\n  function MakeRoom(ANumber: integer): TArray&lt;IRoom&gt;;\n  function MakeDoor(AFromRoom, AToRoom: IRoom): IDoor;  \n\n  class property Instance: IMazeFactory read GetInstance;\nend;\n\nFunction MazeFactoryInstance: IMazeFactory\nbegin\n  result := TMazeFactory.Instance;\nend;\n\nclass function TMazeFactory.GetInstance: IMazeFactory;\nbegin\n  if FInstance = nil then\n    FInstance := TMazeFactory.Create;\n  result := FInstance; \nend;\n\nfunction TMazeFactory.MakeMaze: IMaze;\nbegin\n   // Определение не важно для примера\nend;\n\nconstructor TMazeFactory.Create;\nbegin\n  inherited Create;\nend;\n\nfunction TMazeFactory.MakeWall: IWall;\nbegin\n   // Определение не важно для примера\nend;\n\nfunction TMazeFactory.MakeRoom(ANumber: integer): TArray&lt;IRoom&gt;;\nbegin\n   // Определение не важно для примера\nend;\n\nfunction TMazeFactory.MakeDoor(AFromRoom: IRoom; AToRoom: IRoom): IDoor;\nbegin\n   // Определение не важно для примера\nend;\n\nend.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br></div></div><h3 id="прототип-prototype" tabindex="-1"><a class="header-anchor" href="#прототип-prototype" aria-hidden="true">#</a> Прототип (Prototype)</h3><p>Это мой любимый паттерн. Для его использования передавайте экземпляры прототипов в конструктор. Затем используйте их для создания клонов в фабрике. Такой подход предоставляет возможности для расширения, когда у вас нет доступа до кода (похоже на плагины или расширения определяемые пользователем).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>unit IntfMazeFactory;\n\ninterface\nuses\n  system.generics.collections;\n\ntype\n\nIMaze = interface\n  function Clone: IMaze;\n\n // Остальное определение не важно для примера\nend;\n\nIWall = interface\n  function Clone: IWall;\n // Остальное определение не важно для примера\nend;\n\nIRoom = interface\n  function Clone: IRoom;\n\n // Остальное определение не важно для примера\nend;\n\nIDoor = interface\n  function Clone: IDoor;\n  procedure Initialize(AFromRoom, AToRoom: IRoom); //mutator\n // Остальное определение не важно для примера\nend;\n\nTMazePrototypeFactory = Class \nprivate\n  FProtoMaze: IMaze; \n  FProtoWall: IWall; \n  FProtoRoom: IRoom; \n  FProtoDoor: IDoor;\npublic\n  constructor Create(AMaze: IMaze; AWall: IWall; ARoom: IRoom; ADoor: IDoor);\n\n  function MakeMaze: IMaze;\n  function MakeWall: IWall;\n  function MakeRoom(ANumber: integer): TArray&lt;IRoom&gt;;\n  function MakeDoor(AFromRoom, AToRoom: IRoom): IDoor;  \nend;\n\n// Мы можем использовать фабрику как параметр\n//   MazeGame.CreateMaze(AFactory);\n\nimplementation\n\nconstructor TMazePrototypeFactory.Create(AMaze: IMaze; AWall: IWall; ARoom: IRoom; ADoor: IDoor);\nbegin\n  inherited Create;\n  FProtoMaze := AMaze; \n  FProtoWall := AWall; \n  FProtoRoom := ARoom; \n  FProtoDoor := ADoor;\nend;\n\nfunction TMazePrototypeFactory.MakeMaze: IMaze;\nbegin\n  result := FProtoMaze.Clone;\nend;\n\nfunction TMazePrototypeFactory.MakeWall: IWall;\nbegin\n  result := FProtoWall.Clone;\nend;\n\nfunction TMazePrototypeFactory.MakeRoom(ANumber: integer): TArray&lt;IRoom&gt;;\nbegin\n  for i := 1 to ANumber do\n    result.Add(FProtoRoom.Clone);\nend;\n\nfunction TMazePrototypeFactory.MakeDoor(AFromRoom: IRoom; AToRoom: IRoom): IDoor;\nbegin\n  result := ARoom.Clone;\n  result.Initialize(AFromRoom, AToRoom);\nend;\n\nend.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br><span class="line-number">48</span><br><span class="line-number">49</span><br><span class="line-number">50</span><br><span class="line-number">51</span><br><span class="line-number">52</span><br><span class="line-number">53</span><br><span class="line-number">54</span><br><span class="line-number">55</span><br><span class="line-number">56</span><br><span class="line-number">57</span><br><span class="line-number">58</span><br><span class="line-number">59</span><br><span class="line-number">60</span><br><span class="line-number">61</span><br><span class="line-number">62</span><br><span class="line-number">63</span><br><span class="line-number">64</span><br><span class="line-number">65</span><br><span class="line-number">66</span><br><span class="line-number">67</span><br><span class="line-number">68</span><br><span class="line-number">69</span><br><span class="line-number">70</span><br><span class="line-number">71</span><br><span class="line-number">72</span><br><span class="line-number">73</span><br><span class="line-number">74</span><br><span class="line-number">75</span><br><span class="line-number">76</span><br><span class="line-number">77</span><br><span class="line-number">78</span><br><span class="line-number">79</span><br><span class="line-number">80</span><br><span class="line-number">81</span><br><span class="line-number">82</span><br><span class="line-number">83</span><br></div></div>',19),t={render:function(n,s){const a=(0,e.up)("OutboundLink");return(0,e.wg)(),(0,e.iD)(e.HY,null,[(0,e._)("h1",l,[p,(0,e.Uk)(" "+(0,r.zw)(n.$frontmatter.title),1)]),(0,e._)("p",null,[b,(0,e._)("a",c,[i,(0,e.Wm)(a)])]),u],64)}}}}]);