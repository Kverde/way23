"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[734],{80533:(e,n,r)=>{r.r(n),r.d(n,{data:()=>s});const s={key:"v-5d83dda6",path:"/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-2.html",title:"Написание простого DSL компилятора на Delphi (2. Абстрактное синтаксическое дерево)",lang:"ru-RU",frontmatter:{title:"Написание простого DSL компилятора на Delphi (2. Абстрактное синтаксическое дерево)",date:"2019-06-05",categories:["Delphi"],tags:["Delphi","перевод","компиляторы"]},excerpt:"",headers:[],filePathRelative:"написание-простого-dsl-компилятора-на-delphi-2.md",git:{updatedTime:1692859375e3}}},96810:(e,n,r)=>{r.r(n),r.d(n,{default:()=>Z});var s=r(66252),a=r(3577);const l={id:"frontmatter-title",tabindex:"-1"},i=(0,s._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),p=(0,s.Uk)("Перевод поста "),t={href:"https://www.thedelphigeek.com/2017/08/writing-simple-dsl-compiler-with-delphi_28.html",target:"_blank",rel:"noopener noreferrer"},d=(0,s.Uk)("Writing a Simple DSL Compiler with Delphi (2. Abstract Syntax Tree)"),D=(0,s.Uk)("."),o=(0,s.Uk)('Эта статья представляет собой описание абстрактного синтаксического дерева, используемого для представления "Языка". Если вы только начинаете читать эту серию, то я бы рекомендовал вам начать с '),c={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-0/",target:"_blank",rel:"noopener noreferrer"},m=(0,s.Uk)("этого поста"),u=(0,s.Uk)("."),b=(0,s.Uk)("Пожалуйста, имейте в виду, что эта статья описывают начальную реализацию AST. Если вы хотите просматривать код во время чтения статьи, убедитесь, что вы переключились на ветку "),B={href:"https://github.com/gabr42/SimpleDSLCompiler/tree/dsl_v1",target:"_blank",rel:"noopener noreferrer"},g=(0,s.Uk)("dsl_v1"),h=(0,s.Uk)("."),S={href:"https://ru.wikipedia.org/wiki/%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B5_%D1%81%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5_%D0%B4%D0%B5%D1%80%D0%B5%D0%B2%D0%BE",target:"_blank",rel:"noopener noreferrer"},T=(0,s.Uk)("Абстрактное синтаксическое дерево"),k=(0,s.Uk)(" является, проще говоря, символическим представлением программы в виде дерева."),A=(0,s.Uk)("В то время как текстовое представление программы хорошо подходит для нас, людей, компьютерам тяжело с ним справляться. Поэтому специальная часть любого интерпретатора или компилятора, называемая "),f={href:"https://ru.wikipedia.org/wiki/%D0%A1%D0%B8%D0%BD%D1%82%D0%B0%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7%D0%B0%D1%82%D0%BE%D1%80",target:"_blank",rel:"noopener noreferrer"},v=(0,s.Uk)("парсер"),_=(0,s.Uk)(", читает входной поток и преобразует его в машиночитаемый формат — AST. Это дерево может использоваться для множества целей. Мы можем, например, скормить его "),I={href:"https://ru.wikipedia.org/wiki/%D0%98%D0%BD%D1%82%D0%B5%D1%80%D0%BF%D1%80%D0%B5%D1%82%D0%B0%D1%82%D0%BE%D1%80",target:"_blank",rel:"noopener noreferrer"},w=(0,s.Uk)("интерпретатору"),E=(0,s.Uk)(" который запустит программу для нас, или мы можем скормить его "),y={href:"https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80",target:"_blank",rel:"noopener noreferrer"},F=(0,s.Uk)("компилятору"),U=(0,s.Uk)(" для генерации запускаемого модуля, или "),x={href:"https://ru.wikipedia.org/wiki/%D0%9A%D1%80%D0%BE%D1%81%D1%81-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80",target:"_blank",rel:"noopener noreferrer"},C=(0,s.Uk)("кросс-компилятору"),L=(0,s.Uk)(" для генерации эквивалентной программы на другом языке программирования."),G=(0,s.Uk)("В действительности, этот процесс обычно еще более сложный. Парсер использует специальный входной модуль называемый "),W={href:"https://ru.wikipedia.org/wiki/%D0%9B%D0%B5%D0%BA%D1%81%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%B8%D0%B9_%D0%B0%D0%BD%D0%B0%D0%BB%D0%B8%D0%B7",target:"_blank",rel:"noopener noreferrer"},V=(0,s.Uk)("токинизатор"),O=(0,s.Uk)(" для чтения входного потока и компилятор обычно не создаёт исполняемый модуль напрямую, но производит несколько файлов, которые линкуются в конечную программу."),P=(0,s.Uk)("В случая моего игрушечного проекта компилятора, парсер использует отдельный токинизатор, а компилятор не создаёт запускаемый файл непорсредственно, а производит несколько файлов которые "),N={href:"https://ru.wikipedia.org/wiki/%D0%9A%D0%BE%D0%BC%D0%BF%D0%BE%D0%BD%D0%BE%D0%B2%D1%89%D0%B8%D0%BA",target:"_blank",rel:"noopener noreferrer"},R=(0,s.Uk)("линкуются"),q=(0,s.Uk)(" в конечную программу."),z=(0,s._)("p",null,"В случае моего игрушечного компилятора, парсер использует отдельный токинизатор, в то время как все вроцессы вывода (такие как компилятор) генерируют код, без дополнительных шагов (например, линковки).",-1),H=(0,s._)("p",null,[(0,s._)("img",{src:"images/architecture.png",alt:"Структура компилятора",title:"Структура компилятора"})],-1),Y=(0,s._)("p",null,"Достаточно очевидно, что AST является центральной частью всего проекта и поэтому я решил рассказать о нём перед токинизатором и парсером.",-1),$=(0,s.Uk)("В моём случае (и позвольте мне напомнить вам снова, что всё последующее описание применяется к ветке "),j={href:"https://github.com/gabr42/SimpleDSLCompiler/tree/dsl_v1",target:"_blank",rel:"noopener noreferrer"},J=(0,s.Uk)("dsl_v1"),K=(0,s.Uk)("), AST программы начинается с очень простого интерфейса "),M=(0,s._)("code",null,"ISimpleDSLAST",-1),Q=(0,s.Uk)(". (я буду показывать все типы в сокращённой форме без геттеров и сеттеров)."),X=(0,s.uE)('<div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>IASTFunctions = interface\n  function  Add(const func: IASTFunction): integer;\n  function  Count: integer;\n  function  IndexOf(const name: string): integer;\n  property Items[idxFunction: integer]: IASTFunction read GetItems; default;\nend; { IASTFunctions }\n\nISimpleDSLAST = interface\n   property Functions: IASTFunctions read GetFunctions;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br></div></div><p>Программа в &quot;Языке&quot; это не более чем коллекция функций и интерфейс отражает это.</p><p>Каждая функция имеет имя, список параметров и тело.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TParameterList = TList&lt;string&gt;;\n\nIASTFunction = interface [&#39;{FA4F603A-FE89-40D4-8F96-5607E4EBE511}&#39;]\n   property Name: string read GetName write SetName;\n   property ParamNames: TParameterList read GetParamNames;\n   property Body: IASTBlock read GetBody write SetBody;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Тело функции не более чем коллекция операторов.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TStatementList = TList;\n\nIASTBlock = interface\n   property Statements: TStatementList read GetStatements;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Оператором является либо оператор <strong>if</strong>, либо оператор <strong>return</strong>. Других вариантов нет.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TASTStatementType = (stIf, stReturn);\n\nIASTStatement = interface\nend; { IASTStatement }\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>IASTStatement</code> это просто родительский интерфейс для всех интерфейсов операторов и никогда не создаётся сам по себе.</p><p>Оператор <strong>return</strong> имеет только одну часть — выражение, которое вычисляется и затем возвращается в виде результат функции.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>IASTReturnStatement = interface(IASTStatement)\n   property Expression: IASTExpression read GetExpression write SetExpression;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Оператор <strong>if</strong> более сложный. Он имеет условие (которое тоже является выражением) и следующие за <strong>then</strong> и <strong>else</strong> блоки. (и, как мы уже знаем, блок это просто коллекция операторов)</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>IASTIfStatement = interface(IASTStatement)\n   property Condition: IASTExpression read GetCondition write SetCondition;\n   property ThenBlock: IASTBlock read GetThenBlock write SetThenBlock;\n   property ElseBlock: IASTBlock read GetElseBlock write SetElseBlock;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>Выражение может содержать слагаемое или бинарную операцию с двумя слагаемыми. На данный момент поддерживаются только три операции: сложение, вычитание и сравнение. В Языке нет унарных операторов, так вы не можете написать такой оператор <code>return -3</code>, а должны использовать такую форму <code>return 0-3</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TBinaryOperation = (opNone, opAdd, opSubtract, opCompareLess);\nIASTExpression = interface\n   property Term1: IASTTerm read GetTerm1 write SetTerm1;\n   property Term2: IASTTerm read GetTerm2 write SetTerm2;\n   property BinaryOp: TBinaryOperation read GetBinaryOp write SetBinaryOp;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Слагаемое может быть константой, переменной или вызовом функции.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TASTTermType = (termConstant, termVariable, termFunctionCall);\n\nIASTTerm = interface\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br></div></div><p><code>IASTTerm</code>, также как <code>IASTStatement</code>, является родительским интерфейсом</p><p>Константа — просто числовое значение, вычислимое парсером.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>IASTTermConstant = interface(IASTTerm)\n   property Value: integer read GetValue write SetValue;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p><em>Переменные</em> в действительности имеют неверное название. Язык не поддерживает переменные. В коде могут быть только ссылки на параметры функций. Так как вложенные функции не поддерживаются, то каждый параметр может быть представлен своим индексом в списке параметров (который, также вычисляется парсером).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>IASTTermVariable = interface(IASTTerm)\n   property VariableIdx: integer read GetVariableIdx write SetVariableIdx;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>И последняя часть AST — <em>вызов функции</em> содержит индекс вызываемой нами функции и список параметров которые мы передаём в функцию. Параметры являются выражением.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TExpressionList = TList;\nIASTTermFunctionCall = interface(IASTTerm)\n   property FunctionIdx: integer read GetFunctionIdx write SetFunctionIdx;\n   property Parameters: TExpressionList read GetParameters;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>В действительности, в модуле <code>SimpleDSLCompiler.AST</code> больше ничего нет кроме этого набора интерфейсов и очень тривиальных объектов реализующих их. Этой информации достаточно чтобы представлять семантику оригинальной программы (форматирование теряется во время парсинга) и дальше она может быть подана на вход компилятору.</p>',25),Z={render:function(e,n){const r=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.iD)(s.HY,null,[(0,s._)("h1",l,[i,(0,s.Uk)(" "+(0,a.zw)(e.$frontmatter.title),1)]),(0,s._)("p",null,[p,(0,s._)("a",t,[d,(0,s.Wm)(r)]),D]),(0,s._)("p",null,[o,(0,s._)("a",c,[m,(0,s.Wm)(r)]),u]),(0,s._)("p",null,[b,(0,s._)("a",B,[g,(0,s.Wm)(r)]),h]),(0,s._)("p",null,[(0,s._)("a",S,[T,(0,s.Wm)(r)]),k]),(0,s._)("p",null,[A,(0,s._)("a",f,[v,(0,s.Wm)(r)]),_,(0,s._)("a",I,[w,(0,s.Wm)(r)]),E,(0,s._)("a",y,[F,(0,s.Wm)(r)]),U,(0,s._)("a",x,[C,(0,s.Wm)(r)]),L]),(0,s._)("p",null,[G,(0,s._)("a",W,[V,(0,s.Wm)(r)]),O]),(0,s._)("p",null,[P,(0,s._)("a",N,[R,(0,s.Wm)(r)]),q]),z,H,Y,(0,s._)("p",null,[$,(0,s._)("a",j,[J,(0,s.Wm)(r)]),K,M,Q]),X],64)}}}}]);