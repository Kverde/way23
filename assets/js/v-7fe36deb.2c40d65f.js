"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[9841],{65415:(a,e,t)=>{t.r(e),t.d(e,{data:()=>l});const l={key:"v-7fe36deb",path:"/%D0%B7%D0%B0%D0%B4%D0%B0%D1%87%D0%B0-bitwise-and.html",title:"Задача Bitwise AND",lang:"ru-RU",frontmatter:{title:"Задача Bitwise AND",date:"2020-01-21",categories:["Алгоритмы"],tags:["Python"]},excerpt:"",headers:[{level:2,title:"Решение",slug:"решение",children:[]}],filePathRelative:"задача-bitwise-and.md",git:{updatedTime:1692859375e3}}},21241:(a,e,t)=>{t.r(e),t.d(e,{default:()=>u});var l=t(66252),n=t(3577);const s={id:"frontmatter-title",tabindex:"-1"},p=(0,l._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),x=(0,l.Uk)("В задаче "),o={href:"https://www.hackerrank.com/challenges/30-bitwise-and/problem",target:"_blank",rel:"noopener noreferrer"},i=(0,l.Uk)("Bitwise AND"),r=(0,l.Uk)(" дано множество чисел [latex]S = \\{1, 2, 3, ..., N\\}[/latex], нужно найти два числа [latex]A[/latex] и [latex]B[/latex] такие что значение [latex]A \\& B[/latex] (побитовый оператор И) наибольшее, но меньше заданного [latex]K[/latex]. Вывести наибольшее возможное [latex]A \\& B[/latex]."),c=(0,l.uE)('<p>Ограничения:</p><ul><li>[latex]2 \\leq N \\leq 10^3[/latex]</li><li>[latex]2 \\leq K \\leq N[/latex]</li></ul><h2 id="решение" tabindex="-1"><a class="header-anchor" href="#решение" aria-hidden="true">#</a> Решение</h2><p>Решение с перебором рабочее, но не проходит по скорости: всего пар [latex]N * (N - 1)[/latex], сложность получается [latex]O(n^2)[/latex].</p><p>У этой задачи есть решение за константное время. Предположим число [latex]K[/latex] нечётное. Это значит что в побитовой записи справа у него находится единица:</p><p>[latex]11_{10} = 1011_2[/latex]</p><p>Рассмотрим [latex]K-1[/latex], в двоичной записи все его цифры совпадают с [latex]K[/latex] кроме последней в которой находится 0:</p><p>[latex]10_{10} = 1010_2[/latex]</p><p>Исходя из этого, для нечётного [latex]K[/latex] всегда выполняется равенство [latex](K - 1) \\&amp; K = K - 1[/latex].</p><p>Так как [latex]N \\geq K[/latex] то мы всегда можем взять [latex]A = K - 1[/latex] и [latex]B = K[/latex] и получить максимальный ответ [latex]K - 1[/latex].</p><p>Остался случай с чётным [latex]K[/latex]. Если [latex]K[/latex] чётное число, то [latex]K-1[/latex] нечётное, для него можно провести те же самые рассуждения и получить ответ [latex]K-2[/latex]. Но можно ли для чётного [latex]K[/latex] получить ответ [latex]K-1[/latex]?</p><p>Рассмотрим детальнее числа входящие в выражение [latex]A \\&amp; B[/latex]. Будем исходит из того что в ответе задачи получается число [latex]K-1[/latex], значит либо [latex]A[/latex], либо [latex]B[/latex] равно [latex]K - 1[/latex]. Предположим число [latex]A = K - 1[/latex]. Число [latex]B[/latex] не может быть меньше [latex]A[/latex], так как должно содержать единицы в тех же позициях что и число [latex]A[/latex]. Чтобы [latex]B[/latex] отличалось и было минимальным оно должно содержать дополнительную единицу в самом правом разряде в котором в [latex]A[/latex] содержится 0. Такое число получается при [latex]B = (K - 1) | K[/latex] (побитовое ИЛИ).</p><p>По условию задачи [latex]A, B \\leq N[/latex]. [latex]A = K - 1[/latex] подходит под это условие, а вот [latex]B = (K - 1) | K[/latex] неизвестно. Пример с числами:</p><ul><li>[latex]K = 46_{10} = 101110_2[/latex]</li><li>[latex]K - 1 = 45_{10} = 101101_2[/latex]</li><li>[latex](K - 1) | K = 101111_2 = 47_{10}[/latex]</li></ul><p>При выполнении условия [latex](K - 1) | K \\leq N[/latex] получаем что максимально возможное число в ответе [latex]K - 1[/latex]. Если же условие не выполняется, то ответ будет [latex]K - 2[/latex].</p><p>Причём чётность числа проверять не обязательно. Решение для чётного [latex]K[/latex] всегда подходит и для нечётного, так как условие [latex](K - 1) | K \\leq N[/latex] всегда выполняется для нечётного [latex]K \\leq N[/latex].</p><p>Код решения на Python:</p><div class="language-python ext-py line-numbers-mode"><pre class="language-python"><code>n<span class="token punctuation">,</span> k <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token keyword">for</span> x <span class="token keyword">in</span> <span class="token builtin">input</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>split<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>\n\n<span class="token keyword">print</span><span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>k <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">|</span> k <span class="token operator">&lt;=</span> n <span class="token keyword">else</span> k <span class="token operator">-</span> <span class="token number">2</span><span class="token punctuation">)</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div>',18),u={render:function(a,e){const t=(0,l.up)("OutboundLink");return(0,l.wg)(),(0,l.iD)(l.HY,null,[(0,l._)("h1",s,[p,(0,l.Uk)(" "+(0,n.zw)(a.$frontmatter.title),1)]),(0,l._)("p",null,[x,(0,l._)("a",o,[i,(0,l.Wm)(t)]),r]),c],64)}}}}]);