"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[1489],{20424:(e,n,r)=>{r.r(n),r.d(n,{data:()=>s});const s={key:"v-5346c9ec",path:"/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-5.html",title:"Написание простого DSL компилятора на Delphi (5. Фреймворк)",lang:"ru-RU",frontmatter:{title:"Написание простого DSL компилятора на Delphi (5. Фреймворк)",date:"2019-06-08",categories:["Delphi"],tags:["Delphi","перевод","компиляторы"]},excerpt:"",headers:[],filePathRelative:"написание-простого-dsl-компилятора-на-delphi-5.md",git:{updatedTime:1692859375e3}}},92859:(e,n,r)=>{r.r(n),r.d(n,{default:()=>T});var s=r(66252),a=r(3577);const l={id:"frontmatter-title",tabindex:"-1"},p=(0,s._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),i=(0,s.Uk)("Перевод поста "),o={href:"https://www.thedelphigeek.com/2017/10/writing-simple-dsl-compiler-with-delphi.html",target:"_blank",rel:"noopener noreferrer"},c=(0,s.Uk)("Writing a Simple DSL Compiler with Delphi (5. Framework)"),t=(0,s.Uk)("."),d=(0,s.Uk)("Эта статья представляет собой описание фреймворка используемого для проекта моего языка программирования. Если вы только начинаете читать эту серию, то я бы рекомендовал вам начать с "),D={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-0/",target:"_blank",rel:"noopener noreferrer"},b=(0,s.Uk)("этого поста"),m=(0,s.Uk)("."),u=(0,s.Uk)("Сейчас у нас есть работающий "),B={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-4/",target:"_blank",rel:"noopener noreferrer"},S=(0,s.Uk)("парсер"),g=(0,s.Uk)(" который преобразует строку кода в "),h={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-2/",target:"_blank",rel:"noopener noreferrer"},C=(0,s.Uk)("абстрактное синтаксическое дерево"),F=(0,s.Uk)(". Однако ещё не время писать о самой интересной части — компиляторе — сначала мы должны сделать интеграцию и тестирование."),y=(0,s.uE)('<p>Мой игрушечный компилятор использует очень простой фреймворк доступ к которому производится через интерфейс <code>ISimpleDSLCompiler</code> (модуль <code>SimpleDSLCompiler</code>). Уместная часть интерфейса показана ниже:</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  ISimpleDSLCompiler = interface [&#39;{7CF78EC7-023B-4571-B310-42873921B0BC}&#39;]\n    function  Codegen: boolean;\n    function  Compile(const code: string): boolean;\n    function  Parse(const code: string): boolean;\n    property AST: ISimpleDSLAST read GetAST;\n    property Code: ISimpleDSLProgram read GetCode;\n    property ASTFactory: TSimpleDSLASTFactory       read GetASTFactory write SetASTFactory;\n    property CodegenFactory: TSimpleDSLCodegenFactory       read GetCodegenFactory write SetCodegenFactory;\n    property ParserFactory: TSimpleDSLParserFactory       read GetParserFactory write SetParserFactory;\n    property TokenizerFactory: TSimpleDSLTokenizerFactory       read GetTokenizerFactory write SetTokenizerFactory;\n   end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div><p>Фреймворк представляет функции для разбора входных данных (<code>Parse</code>), генерации исполняемого кода (<code>Codegen</code>) и оба эти действия в один шаг (<code>Compile</code>), но он понятия не имеет как это делать. Вся функциональность реализована снаружи — через токинизатор, парсер и движок генерации кода что который создаётся в фабричном методе (<code>TokenizerFactory</code>).</p><p>Чтобы сделать конфигурацию простой, <code>TSimpleDSLCompiler.Create</code> устанавливает фабрики по умолчанию, создавая типичные классы движков. Если вы хотите подключить свою собственную реализацию отдельного шага, вы можете сделать это установив подходящее свойство <code>XXXFactory</code> перед вызовом любой функции этого интерфейса. Мы будем использовать эту возможность для реализации &quot;AST Dumper&quot; в следующей части этого блога.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>constructor TSimpleDSLCompiler.Create;\nbegin\n  inherited Create;\n  ASTFactory := CreateSimpleDSLAST;\n  CodegenFactory := CreateSimpleDSLCodegen;\n  ParserFactory := CreateSimpleDSLParser;\n  TokenizerFactory := CreateSimpleDSLTokenizer;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Давайте быстро взглянем на все три функции API. Самая важная — <code>Compile</code>, не делает ничего кроме вызова парсера и (если обрабатываемый код корректен) генератора кода. Здесь нет ничего особенного.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLCompiler.Compile(const code: string): boolean;\nbegin\n  Result := Parse(code);\n  if Result then\n    Result := Codegen;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Вторая — <code>Parse</code>, создаёт движки парсера и токинезатора, подготавливает AST (<code>FAST</code>) и вызывает метод парсера <code>Parse</code>. Большинство из этого просто обвязка, и вся реальная работа делается в <code>parser.Parse</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLCompiler.Parse(const code: string): boolean;\nvar\n  parser   : ISimpleDSLParser;\n  tokenizer: ISimpleDSLTokenizer;\nbegin\n  LastError := &#39;&#39;;\n  parser := ParserFactory();\n  tokenizer := TokenizerFactory();\n  FAST := ASTFactory();\n  Result := parser.Parse(code, tokenizer, FAST);\n  if not Result then begin\n    FAST := nil;\n    LastError := (parser as ISimpleDSLErrorInfo).ErrorInfo;\n  end\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Последний — <code>Codegen</code> такой же простой. После нескольких проверок он создаёт движок генерации кода и вызывает его метод <code>Generate</code> передавая в него AST. Мы не рассматривали генератор кода, так что пока достаточно сказать, что генератор кода предоставляет одну функцию — <code>Generate</code> которая конвертирует <code>ISimpleDSLAST</code> в <code>ISimpleDSLProgram</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLCompiler.Codegen: boolean;\nvar\n  codegen  : ISimpleDSLCodegen;\nbegin\n  LastError := &#39;&#39;;\n  if not assigned(FAST) then\n    Exit(SetError(&#39;Nothing to do&#39;))\n  else begin\n    codegen := CodegenFactory();\n    Result := codegen.Generate(FAST, FCode);\n    if not Result then begin\n      FCode := nil;\n      LastError := (codegen as ISimpleDSLErrorInfo).ErrorInfo;\n    end;\n  end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>Всё это позволяет нам очень просто вызывать компилятор:</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>compiler := CreateSimpleDSLCompiler;\nif not compiler.Compile(CMultiProcCode) then\n  Writeln(&#39;Compilation/codegen error: &#39; +     (compiler as ISimpleDSLErrorInfo).ErrorInfo); \n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>В следующей части мы увидим как можно сохранить сгенерированное AST в текстовую форму заменой <code>CodegenFactory</code>.</p>',14),T={render:function(e,n){const r=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.iD)(s.HY,null,[(0,s._)("h1",l,[p,(0,s.Uk)(" "+(0,a.zw)(e.$frontmatter.title),1)]),(0,s._)("p",null,[i,(0,s._)("a",o,[c,(0,s.Wm)(r)]),t]),(0,s._)("p",null,[d,(0,s._)("a",D,[b,(0,s.Wm)(r)]),m]),(0,s._)("p",null,[u,(0,s._)("a",B,[S,(0,s.Wm)(r)]),g,(0,s._)("a",h,[C,(0,s.Wm)(r)]),F]),y],64)}}}}]);