"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[8884],{21386:(n,s,e)=>{e.r(s),e.d(s,{data:()=>a});const a={key:"v-12ebdd86",path:"/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-inte.html",title:"Написание простого DSL компилятора на Delphi (Intermezzo)",lang:"ru-RU",frontmatter:{title:"Написание простого DSL компилятора на Delphi (Intermezzo)",date:"2019-06-10",categories:["Delphi"],tags:["Delphi","перевод","компиляторы","грамотное-программирование"]},excerpt:"",headers:[{level:2,title:"introduction.dpr",slug:"introduction-dpr",children:[]}],filePathRelative:"написание-простого-dsl-компилятора-на-delphi-inte.md",git:{updatedTime:1692859375e3}}},64609:(n,s,e)=>{e.r(s),e.d(s,{default:()=>F});var a=e(66252),r=e(3577);const l={id:"frontmatter-title",tabindex:"-1"},p=(0,a._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),i=(0,a.Uk)("Перевод поста "),b={href:"https://www.thedelphigeek.com/2017/10/writing-simple-dsl-compiler-with-delphi_17.html",target:"_blank",rel:"noopener noreferrer"},t=(0,a.Uk)("Writing a Simple DSL Compiler with Delphi (Intermezzo)"),c=(0,a.Uk)("."),u=(0,a.Uk)("Когда я подготавливал статью про компилятор для моего "),m={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-0/",target:"_blank",rel:"noopener noreferrer"},d=(0,a.Uk)("игрушечного языкового проекта"),o=(0,a.Uk)(", я обнаружил что концепцию обёртки целой программы в связку анонимных функций (что делает компилятор) чрезвычайно сложна для объяснения. Поэтому я подготовил упрошенную версию компилятора, написанную для очень упрошенного языка... а затем я так и не смог остановится и добавил AST, пакрсер и токинезатор."),g=(0,a.Uk)("Результатом всего этого является программа "),T={href:"https://github.com/gabr42/SimpleDSLCompiler/blob/master/introduction.dpr",target:"_blank",rel:"noopener noreferrer"},h=(0,a.Uk)("introduction.dpr"),v=(0,a.Uk)(", автономная программа которая содержит полностью язык (очень тривиальный) вместе с полной документацией, написанная в стиле "),A={href:"https://ru.wikipedia.org/wiki/%D0%93%D1%80%D0%B0%D0%BC%D0%BE%D1%82%D0%BD%D0%BE%D0%B5_%D0%BF%D1%80%D0%BE%D0%B3%D1%80%D0%B0%D0%BC%D0%BC%D0%B8%D1%80%D0%BE%D0%B2%D0%B0%D0%BD%D0%B8%D0%B5",target:"_blank",rel:"noopener noreferrer"},x=(0,a.Uk)("Грамотного программирования"),C=(0,a.Uk)(". Упрощено — вы можете читать её сверху вниз как историю."),k=(0,a.uE)('<p>В качестве intermezzo и для упрощения моего объяснения компилятора, я опишу эту программу здесь полностью, отформатировав её как пост в блог.</p><h2 id="introduction-dpr" tabindex="-1"><a class="header-anchor" href="#introduction-dpr" aria-hidden="true">#</a> introduction.dpr</h2><p>Эта программа является мягким введением в тему &quot;compiler-compiler&quot; (программ которые генерируют компиляторы или их части). Она написана в стиле Грамотного программирования и предназначена для чтения от начала до конца.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>program introduction;\n{$APPTYPE CONSOLE}\n{$R *.res}\nuses\n  System.SysUtils,\n  System.Classes,\n  System.Character,\n\n  System.Generics.Collections;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p>Наша задача: мы хотим вычислять выражения в форме</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>   number1 + number2 + ... + numberN\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Все числа целые и позитивные, только один оператор — сложение, переполнение игнорируется.</p><p>Формально, мы можем описать нашу программу следующей грамматикой</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>S → Term\nTerm → number\nTerm → Term &#39;+&#39; Term\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br></div></div><p>Пробельные символы игнорируются парсером и следовательно не являются частью грамматики.</p><p>Мы начнём с очень простого AST который будет хранить разобранную версию программы</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TTerm = class abstract\n  end; \n\n  TAST = TTerm;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br></div></div><p>На верху нашего дерева находится &#39;term&#39; (слагаемое). <em>Слагаемое</em> может быть либо <em>константой</em> либо <em>сложением</em>.</p><p><em>Константа</em>, как и можно ожидать, содержит целочисленное значение.</p><p>Здесь мы непоследовательны — язык позволяет только позитивные числа, но AST более общее и допускает негативные числа. Мы будем просто игнорировать это.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>  TConstant = class(TTerm)\n  strict private\n    FValue: integer;\n  public\n    constructor Create(AValue: integer);\n    property Value: integer read FValue write FValue;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p><em>Сложение</em> — бинарная операция над двумя <em>слагаемыми</em> (левым и правым).</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>  TAddition = class(TTerm)\n  strict private\n    FTerm1: TTerm;\n    FTerm2: TTerm;\n  public\n    constructor Create(ATerm1, ATerm2: TTerm);\n    destructor  Destroy; override;\n    property Term1: TTerm read FTerm1 write FTerm1;\n    property Term2: TTerm read FTerm2 write FTerm2;\n  end;\n\nconstructor TConstant.Create(AValue: integer);\nbegin\n  inherited Create;\n  FValue := AValue;\nend;\n\nconstructor TAddition.Create(ATerm1, ATerm2: TTerm);\nbegin\n  inherited Create;\n  FTerm1 := ATerm1;\n  FTerm2 := ATerm2;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div><p>Объект <code>TAddition</code> является владельцем своих дочерних объектов.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>destructor TAddition.Destroy;\nbegin\n  FreeAndNil(FTerm1);\n  FreeAndNil(FTerm2);\n  inherited;\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Следующая функция строит AST из массива чисел. Владелец отвечает за уничтожение полученного AST.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CreateAST(const values: TArray): TAST;\nvar\n  iValue: integer;\nbegin\n  if Length(values) = 0 then\n\n    Exit(nil);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Мы будем создавать <em>слагаемые</em> из массив в начиная с конца к началу и использовать промежуточные результаты как слагаемые в следующих слагаемых.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>  Result := TConstant.Create(values[High(values)]);\n\n  for iValue := High(values) - 1 downto Low(values) do\n    Result := TAddition.Create(TConstant.Create(values[iValue]), Result);\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Вызов <code>CreateAST([1, 2, 3])</code> создаст следующее AST с тремя узлами:</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>TAddition\n   Term1 = TConstant\n           Value = 1\n   Term2 = TAddition\n           Term1 = TConstant\n                   Value = 2\n           Term2 = TConstant\n                   Value = 3\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Давайте сделаем из этого тест.</p><p>Сначала, несколько вспомогательных функций, которые одновременно проверяют и преобразовывают тип.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function IsConstant(term: TTerm; out add: TConstant): boolean;\nbegin\n  Result := term is TConstant;\n  if Result then\n    add := TConstant(term);\nend;\n\nfunction IsAddition(term: TTerm; out add: TAddition): boolean;\nbegin\n  Result := term is TAddition;\n  if Result then\n    add := TAddition(term);\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br></div></div><p>И теперь реальный тест.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TestCreateAST;\nvar\n  add1  : TAddition;\n  add2  : TAddition;\n  ast   : TAST;\n  const1: TConstant;\n  const2: TConstant;\n  const3: TConstant;\nbegin\n  ast := CreateAST([1, 2, 3]);\n  try\n    if assigned(ast)\n       and IsAddition(ast, add1)\n       and IsConstant(add1.Term1, const1) and (const1.Value = 1)\n       and IsAddition(add1.Term2, add2)\n       and IsConstant(add2.Term1, const2) and (const2.Value = 2)\n       and IsConstant(add2.Term2, const3) and (const3.Value = 3)\n    then\n      // everything is fine\n    else\n      raise Exception.Create(&#39;CreateAST is not working correctly!&#39;);\n  finally FreeAndNil(ast); end;\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br></div></div><p>Мы напишем просто парсер который создаст AST из выражения в форме <code>number1 + number2 + ... numberN</code>.</p><p>Наш &quot;язык&quot; имеет только два токена: &#39;number&#39; (число) и &#39;addition&#39; (сложение). Пробельные символы не важны будут игнорироваться токинезатором (лексическим анализатором). Все не распознанные символы будут возвращать токен &#39;unknown&#39;.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TTokenKind = (tkNumber, tkAddition, tkUnknown);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Больше информации про токены:</p><ul><li>tkNumber — &quot;\\d+&quot;</li><li>tkAddition — &quot;+&quot;</li><li>&quot;\\s+&quot; — пропускаются</li><li>tkUnknown — принимает всё остальное: &quot;[^\\d+\\s]&quot;</li></ul><p>Токинезатор и парсер нуждаются только в следующей информации:</p><ul><li>Входная строка.</li><li>Текущая позиция.</li></ul><p>Класс <code>TStringStream</code> обеспечивает оба эти пункта так что мы будем использовать его.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>  TParserState = TStringStream;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>Единственная функция токинезатора возвращает следующий токен и его значение как параметры с модификатором <code>var</code> и возвращает <code>True</code> если пара токен\\значение была возвращена и <code>False</code> если достигнут конец потока.</p><p>Эта реализация очень проста, но одновременно крайне неоптимизирована.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function GetToken(state: TParserState; var token: TTokenKind; var value: string): boolean;\nvar\n  nextChar: string;\n  position: int64;\nbegin\n  repeat\n    nextChar := state.ReadString(1);\n    Result := (nextChar &lt;&gt; &#39;&#39;);\n    // Ignore whitespace\n  until (not Result) or (not nextChar[1].IsWhiteSpace);\n\n  if Result then begin\n    value := nextChar[1];\n\n    // Addition\n    if value = &#39;+&#39; then\n      token := tkAddition\n\n    // Number\n    else if value[1].IsNumber then begin\n      token := tkNumber;\n      repeat\n        position := state.Position;\n        nextChar := state.ReadString(1);\n\n        // End of stream, stop\n        if nextChar = &#39;&#39; then\n          break //repeat\n\n        // Another number, append\n        else if nextChar[1].IsNumber then\n          value := value + nextChar[1]\n\n        // Read too far, retract\n        else begin\n          state.Position := position;\n          break; //repeat\n        end;\n      until false;\n    end\n\n    // Unexpected input\n    else\n      token := tkUnknown;\n  end;\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br><span class="line-number">42</span><br><span class="line-number">43</span><br><span class="line-number">44</span><br><span class="line-number">45</span><br><span class="line-number">46</span><br><span class="line-number">47</span><br></div></div><p>Необходимо несколько тестов для токинезатора..</p><p><code>ExpectFail(state)</code> вызывает <code>GetToken</code> и ожидает что он вернёт <code>False</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure ExpectFail(state: TParserState);\nvar\n  token: TTokenKind;\n  value: string;\nbegin\n  if GetToken(state, token, value) then\n    raise Exception.Create(&#39;ExpectFail failed&#39;);\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br></div></div><p><code>Expect(State, token, value)</code> вызывает <code>GetNextToken</code> и ожидает что он вернёт <code>True</code> и те же токен/значение которые переданы в параметрах.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure Expect(state: TParserState; expectedToken: TTokenKind;   expectedValue: string);\nvar\n  token: TTokenKind;\n  value: string;\nbegin\n  if not GetToken(state, token, value) then\n    raise Exception.Create(&#39;Expect failed&#39;)\n\n  else if token &lt;&gt; expectedToken then\n    raise Exception.CreateFmt(            &#39;Expect encountered invalid token kind (%d, expected %d)&#39;,\n            [Ord(token), Ord(expectedToken)])\n\n  else if value &lt;&gt; expectedValue then\n    raise Exception.CreateFmt(            &#39;Expect encountered invalid value (%s, expected %s)&#39;,\n            [value, expectedValue])\nend;\n\nprocedure TestGetToken;\nvar\n  state: TParserState;\nbegin\n  state := TParserState.Create(&#39;&#39;);\n  ExpectFail(state);\n  FreeAndNil(state);\n\n  state := TParserState.Create(&#39;1&#39;);\n  Expect(state, tkNumber, &#39;1&#39;);\n  ExpectFail(state);\n  FreeAndNil(state);\n\n  state := TParserState.Create(&#39;1+22 333 Ab&#39;);\n  Expect(state, tkNumber, &#39;1&#39;);\n  Expect(state, tkAddition, &#39;+&#39;);\n  Expect(state, tkNumber, &#39;22&#39;);\n  Expect(state, tkNumber, &#39;333&#39;);\n  Expect(state, tkUnknown, &#39;A&#39;);\n  Expect(state, tkUnknown, &#39;b&#39;);\n  ExpectFail(state);\n  FreeAndNil(state);\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br><span class="line-number">39</span><br><span class="line-number">40</span><br><span class="line-number">41</span><br></div></div><p>Парсер принимает любую допустимую строку и преобразует её в AST.</p><p>Если программа корректна, он создаст AST для этой программы, вернёт его в параметре <code>ast</code> и результат функции будет <code>True</code>.</p><p>Если программа не корректна, параметр <code>ast</code> будет <code>nil</code> и результат функции <code>False</code>.</p><p>Пустой ввод не допускается.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function Parse(const prog: string; var ast: TAST): boolean;\nvar\n  accept : TTokenKind;\n  numbers: TList;\n  state  : TParserState;\n  token  : TTokenKind;\n  value  : string;\nbegin\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><p>Мы можем легко увидеть как показанная грамматика генерирует следующую последовательность токенов:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>   tkNumber (tkAddition tkNumber)*\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>(Доказательство опущено в качестве упражнения для читателя)</p><p>Код проверит синтаксис и извлечёт из строки все числа в <code>TArray</code>.</p><p>В конце он передаст этот массив в функцию <code>CreateAST</code> для создания AST.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>   ast := nil;\n  Result := false;\n\n  state := TParserState.Create(prog);\n  try\n    numbers := TList.Create;\n    try\n      accept := tkNumber;\n      while GetToken(state, token, value) do begin\n        if token &lt;&gt; accept then\n          Exit;\n        if accept = tkNumber then begin\n          numbers.Add(StrToInt(value));\n          accept := tkAddition;\n        end\n        else\n          accept := tkNumber;\n      end;\n\n      if accept = tkNumber then\n        // Last token in the program was tkAddition, which is not allowed.\n        Exit;\n\n      if numbers.Count &gt; 0 then begin\n        ast := CreateAST(numbers.ToArray);\n        Result := true;\n      end;\n    finally FreeAndNil(numbers); end;\n  finally FreeAndNil(state); end;\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br></div></div><p>Нам нужно больше тестов...</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TestParse;\nvar\n  add1  : TAddition;\n  add2  : TAddition;\n  ast   : TAST;\n  const1: TConstant;\n  const2: TConstant;\n  const3: TConstant;\nbegin\n  if not Parse(&#39;1+2 + 3&#39;, ast) then\n    raise Exception.Create(&#39;Parser failed&#39;);\n  try\n    if assigned(ast)\n       and IsAddition(ast, add1)\n       and IsConstant(add1.Term1, const1) and (const1.Value = 1)\n       and IsAddition(add1.Term2, add2)\n       and IsConstant(add2.Term1, const2) and (const2.Value = 2)\n       and IsConstant(add2.Term2, const3) and (const3.Value = 3)\n    then\n      // everything is fine\n    else\n      raise Exception.Create(&#39;CreateAST is not working correctly!&#39;);\n  finally FreeAndNil(ast); end;\n\n  if Parse(&#39;1+2 +&#39;, ast) then begin\n    if assigned(ast) then\n      raise Exception.Create(&#39;Invalid program resulted in an AST!)&#39;)\n    else\n      raise Exception.Create(&#39;Invalid program compiled into an empty AST!&#39;);\n  end;\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br></div></div><p>Для интерпретации этого AST мы будем использовать простую рекурсию.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function InterpretAST(ast: TAST): integer;\nvar\n  add1  : TAddition;\n  const1: TConstant;\nbegin\n  if not assigned(ast) then\n    raise Exception.Create(&#39;Result is undefined!&#39;);\n  // Alternatively, we could use Nullable as result, \n  // with Nullable.Null as a default value.\n\n  if IsConstant(ast, const1) then\n    Result := const1.Value\n  else if IsAddition(ast, add1) then\n    Result := InterpretAST(add1.Term1) + InterpretAST(add1.Term2)\n  else\n    raise Exception.Create(&#39;Internal error. Unknown AST element: &#39; +      ast.ClassName);\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>Несколько sanity tests всегда приветствуются...</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TestInterpretAST;\n\n  procedure Test(const testName: string; const values: TArray;    expectedResult: integer);\n  var\n    ast       : TAST;\n    calcResult: integer;\n  begin\n    ast := CreateAST(values);\n    if not assigned(ast) then\n      raise Exception.CreateFmt(&#39;Compilation failed in test %s&#39;, [testName]);\n\n    try\n      calcResult := InterpretAST(ast);\n      if calcResult &lt;&gt; expectedResult then\n        raise Exception.CreateFmt(\n                &#39;Evaluation failed in test %s. &#39; +\n                &#39;Calculated result %d &lt;&gt; expected result %d&#39;,\n                [testName, calcResult, expectedResult]);\n    finally\n      FreeAndNil(ast);\n    end;\n  end;\n\nbegin\n  Test(&#39;1&#39;, [42], 42);\n  Test(&#39;2&#39;, [1, 2, 3], 6);\n  Test(&#39;3&#39;, [2, -2, 3, -3], 0);\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br></div></div><p>Для компиляции этого AST, мы должны:</p>',66),D=(0,a._)("li",null,"Изменить каждый узел с типом 'constant' в анонимную функцию которая возвращает значение этого узла.",-1),f=(0,a._)("li",null,[(0,a.Uk)("Изменить каждый узел с типом 'summation' в анонимную функцию которая возвращает значение двух параметров. "),(0,a._)("ul",null,[(0,a._)("li",null,"Первый - анонимная функция которая вычисляет значение левого слагаемого и"),(0,a._)("li",null,"второй - анонимная функция которая вычисляет значение правого слагаемого")])],-1),S={href:"http://docwiki.embarcadero.com/RADStudio/Tokyo/en/Anonymous_Methods_in_Delphi#Variable_Binding_Mechanism",target:"_blank",rel:"noopener noreferrer"},B=(0,a.Uk)("Механизм связывания переменных"),E=(0,a.Uk)(" заботится о получении правильных входных данных"),R=(0,a.uE)('<div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function MakeConstant(value: integer): TFunc;\nbegin\n  Result :=\n    function: integer\n    begin\n      Result := value;\n    end;\nend;\n\nfunction MakeAddition(const term1, term2: TFunc): TFunc;\nbegin\n  Result :=\n    function: integer\n    begin\n      Result := term1() + term2();\n    end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br></div></div><p>Важная точка здесь в том что не <code>MakeConstant</code> не <code>MakeAddition</code> не делает никаких вычислений. Они просто настраивают анонимный метод и возвращают ссылку на него, что более или менее соответствует созданию объекта и возврату его интерфейса, но с добавление затрат на связывание переменных (variable capturing).</p><p>Кстати, так как наш &quot;язык&quot; только вычисляет целочисленные выражения что всегда на выходе даёт целое число, то &quot;функция которая возвращает число&quot; или <code>TFunc</code> точно подходит под наши требования.</p><p>Для &quot;компиляции&quot; AST мы должны использовать рекурсию так как нам нужно создать дочерне-вычисляемые анонимные функции перед их вычислением (как параметры) для создания анонимной функции вычисляющей родительский узел.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function CompileAST(ast: TTerm): TFunc;\nvar\n  add1: TAddition;\n  const1: TConstant;\nbegin\n  if IsConstant(ast, const1) then\n    // this node represents a constant\n    Result := MakeConstant(const1.Value)\n  else if IsAddition(ast, add1) then\n    // this node represent an expression\n    Result := MakeAddition(CompileAST(add1.Term1), CompileAST(add1.Term2))\n  else\n\n    raise Exception.Create(&#39;Internal error. Unknown AST element: &#39; +      ast.ClassName);\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Этот код работает корректно потому что захватывает <strong>значение</strong> <code>const1.Value</code>, а не ссылку (указатель) на него. Откуда я это знаю? Потому что функция <code>TestCompileAST</code> явным образом проверяет это поведение.</p><p>Вызывая <code>CompileAST(CreateAST[1,2,3])</code> будет сгенерирована следующая анонимная функция:</p><div class="language-text ext-text line-numbers-mode"><pre class="language-text"><code>(*\nfunction: integer\nbegin\n  Result :=\n    (function: integer\n     begin\n       Result := 1;\n     end)()\n    +\n    (function: integer\n     begin\n       Result :=\n         (function: integer\n          begin\n            Result := 2;\n          end)()\n         +\n         (function: integer\n          begin\n            Result := 3;\n          end)();\n     end)();\n\nend;\n*)\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br></div></div><p>(*): я знаю что результатом этого будет уточка памяти так как AST не уничтожается.</p><p>Трудно проверить что сгенерированная анонимная функция в корректной форме, но мы можем запустить её на некотором числе тестов и надеятся что всё ОК 😉</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TestCompileAST;\n\n  procedure Test(const testName: string; const prog: string; expectedResult: integer);\n  var\n    add1      : TAddition;\n    ast       : TAST;\n    calcResult: integer;\n    code      : TFunc;\n    const1    : TConstant;\n  begin\n    if not (Parse(prog, ast) and assigned(ast)) then\n      raise Exception.CreateFmt(&#39;Parser failed in test %s&#39;, [testName]);\n\n    try\n      code := CompileAST(ast);\n      if not assigned(code) then\n\n        raise Exception.CreateFmt(&#39;Compilation failed in test %s&#39;, [testName]);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br></div></div><p>Давайте удостоверимся что <code>ast.Value</code> был связан по значению а не по ссылке.</p><p>Изменение AST сейчас не должно влиять на скомпилированный код.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>       if (IsAddition(ast, add1) and IsConstant(add1.Term1, const1))\n         or IsConstant(ast, const1)\n      then\n        const1.Value := const1.Value + 1\n      else\n        raise Exception.CreateFmt(&#39;Unexpected AST format in test %s&#39;,         [testName]);\n\n      calcResult := code(); //execute the compiled code\n\n      if calcResult &lt;&gt; expectedResult then\n        raise Exception.CreateFmt(\n                &#39;Evaluation failed in test %s. &#39; +\n                &#39;Codegen result %d &lt;&gt; expected result %d&#39;,\n                [testName, calcResult, expectedResult]);\n\n    finally\n      FreeAndNil(ast);\n    end;\n  end;\n\nbegin\n  Test(&#39;1&#39;, &#39;42&#39;, 42);\n  Test(&#39;2&#39;, &#39;1 + 2 + 3&#39;, 6);\n  Test(&#39;3&#39;, &#39;2 + 2 +3+3&#39;, 10);\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br></div></div><p>Если все тесты проходят, мы запустим цикл Чтение-Выполнение-Вывод (Read-Eval-Print Loop) так что пользователь сможет проверить наш компилятор.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure RunREPL;\nvar\n  ast : TAST;\n  prog: string;\nbegin\n  repeat\n    Write(&#39;Enter an expression (empty line exits): &#39;);\n    Readln(prog);\n    if prog = &#39;&#39; then\n      break;\n\n    if not Parse(prog, ast) then\n      Writeln(&#39;Syntax is not valid&#39;)\n    else\n      Writeln(&#39;Result is: &#39;, CompileAST(ast)());\n  until false;\nend;\n\nbegin\n   try\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br></div></div><p>Запустим все модульные тесты для проверки корректности программы.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>     Writeln(&#39;Running AST creation tests ...&#39;);\n    TestCreateAST;\n\n    Writeln(&#39;Running tokenizer tests ...&#39;);\n    TestGetToken;\n\n    Writeln(&#39;Running parser test ...&#39;);\n    TestParse;\n\n    Writeln(&#39;Running AST interpreter tests ...&#39;);\n    TestInterpretAST;\n\n    Writeln(&#39;Running AST compilation tests ...&#39;);\n    TestCompileAST;\n\n    RunREPL;\n  except\n    on E: Exception do begin\n      Writeln(E.ClassName, &#39;: &#39;, E.Message);\n      Readln;\n    end;\n  end;\nend.\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br></div></div>',18),F={render:function(n,s){const e=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[(0,a._)("h1",l,[p,(0,a.Uk)(" "+(0,r.zw)(n.$frontmatter.title),1)]),(0,a._)("p",null,[i,(0,a._)("a",b,[t,(0,a.Wm)(e)]),c]),(0,a._)("p",null,[u,(0,a._)("a",m,[d,(0,a.Wm)(e)]),o]),(0,a._)("p",null,[g,(0,a._)("a",T,[h,(0,a.Wm)(e)]),v,(0,a._)("a",A,[x,(0,a.Wm)(e)]),C]),k,(0,a._)("ul",null,[D,f,(0,a._)("li",null,[(0,a._)("a",S,[B,(0,a.Wm)(e)]),E])]),R],64)}}}}]);