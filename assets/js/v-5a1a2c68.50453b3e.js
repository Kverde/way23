"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[3185],{44927:(n,e,s)=>{s.r(e),s.d(e,{data:()=>a});const a={key:"v-5a1a2c68",path:"/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-3.html",title:"Написание простого DSL компилятора на Delphi (3. Токинезатор)",lang:"ru-RU",frontmatter:{title:"Написание простого DSL компилятора на Delphi (3. Токинезатор)",date:"2019-06-06",categories:["Delphi"],tags:["Delphi","перевод","компиляторы"]},excerpt:"",headers:[{level:2,title:"Токены",slug:"токены",children:[]},{level:2,title:"Интерфейс",slug:"интерфеис",children:[]},{level:2,title:"Чтение входного потока",slug:"чтение-входного-потока",children:[]},{level:2,title:"Одно-символьный буфер",slug:"одно-символьныи-буфер",children:[]}],filePathRelative:"написание-простого-dsl-компилятора-на-delphi-3.md",git:{updatedTime:1692859375e3}}},49990:(n,e,s)=>{s.r(e),s.d(e,{default:()=>N});var a=s(66252),l=s(3577);const r={id:"frontmatter-title",tabindex:"-1"},i=(0,a._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),p=(0,a.Uk)("Перевод поста [Writing a Simple DSL Compiler with Delphi (3. Tokenizer])]("),t={href:"https://www.thedelphigeek.com/2017/09/writing-simple-dsl-compiler-with-delphi.html",target:"_blank",rel:"noopener noreferrer"},c=(0,a.Uk)("https://www.thedelphigeek.com/2017/09/writing-simple-dsl-compiler-with-delphi.html"),o=(0,a.Uk)(")."),u=(0,a.Uk)('Эта статья представляет собой описание токинезатора используемого для представления "Языка". Если вы только начинаете читать эту серию, то я бы рекомендовал вам начать с '),b={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-0/",target:"_blank",rel:"noopener noreferrer"},d=(0,a.Uk)("этого поста"),m=(0,a.Uk)("."),h=(0,a.Uk)("Пожалуйста, имейте в виду, что эта статья описывает начальную реализацию токинезатора. Если вы хотите просматривать код во время чтения статьи, убедитесь, что вы переключились на ветку "),k={href:"https://github.com/gabr42/SimpleDSLCompiler/tree/dsl_v1",target:"_blank",rel:"noopener noreferrer"},D=(0,a.Uk)("dsl_v1"),g=(0,a.Uk)("."),f=(0,a.uE)('<p>С этой статьёй я перемещаюсь в важную часть проекта — код который читает исходный код и превращает его в красивое абстрактное синтаксическое дерево. Другими словами, я буду говорить о парсере.</p><p>Я должен признать что потратил на парсер так мало времени, как мог. В конце концов, моя основная цель конвертировать AST в запускаемый код, не разбор текста. Тем не менее, нельзя написать компилятор без написания парсера.</p><p>Если вы хотите сделать что-то с данными, то вы должны</p><ol><li>Знать формат в котором они записаны.</li><li>Написать код который читает входной поток, разбирает его и создаёт в памяти структуры наполненные данными.</li></ol><p>Первая задача любого хорошего программиста это создание библиотеки которая будет делать самую трудную работу за него. Так было незадолго до того как такие инструменты появились в области написания компиляторов.</p><p>Программисты очень скоро поняли что анализ текста в действительности состоит из двух шагов. На первом шаге вы хотите разделить данныйе на токены (лексемы). Каждый токен представляет собой небольшую часть входных данных имеющую определённое значение. Например, если вы разделите оператор Паскаля</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>a := func(i+42);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br></div></div><p>на отдельные токены, то вы получите</p><ul><li>identifier:a</li><li>whitespace</li><li>becomes</li><li>whitespace</li><li>identifier:func</li><li>left-parent</li><li>identifier:i</li><li>plus</li><li>number:42</li><li>right-parent</li><li>semicolon</li></ul><p>Некоторые символы сразу сопоставляются с собственными токенами, например, &quot;;&quot; становится <code>semicolon</code>. А некоторые сгруппированы, например, &quot;42&quot; становится <code>number</code> со значением 42.</p><p>Вторая часть — парсер использует последовательность токенов производимых токинезатором и пробует понять смысл (семантику) — то есть как токены вписываются в формальную спецификацию языка. Это будет тема следующей статьи.</p>',11),B=(0,a.Uk)("Из-за такого разделения вспомогательные утилиты тоже делятся на две области — одни помогают создавать токинезаторы а другие парсеры. В терминах Unix, например, у нас есть Lex для лексического анализа (токинезация) и Yacc (Yet Another Compiler Compiler) для семантического анализа. В мире Паскаля у нас тоже есть инструменты для генерации компиляторов. Существует довольно приличный "),L={href:"https://github.com/RomanYankovsky/ndyacclex",target:"_blank",rel:"noopener noreferrer"},F=(0,a.Uk)("порт на Delphi"),v=(0,a.Uk)(", "),q={href:"http://wiki.freepascal.org/Plex_and_Pyacc",target:"_blank",rel:"noopener noreferrer"},C=(0,a.Uk)("Plex+Pyacc"),w=(0,a.Uk)(" для FreePascal, довольно старый и неподдерживаемый (но бесплатный) "),T={href:"http://www.soft-gems.net/index.php/tools/delphi-compiler-generator",target:"_blank",rel:"noopener noreferrer"},x=(0,a.Uk)("Delphi Compiler Generator"),S=(0,a.Uk)(" и возможно несколько других инструментов, которых я не нашёл при поверхностным поиске."),_=(0,a._)("p",null,"Вернёмся назад к теме разговора.",-1),E=(0,a._)("p",null,"В моём случае язык крайне простой и следовательно токинезатор тоже. Вместо использования специализированных инструментов я просто пошёл дальше и написал его. Как вы уведите, это очень просто.",-1),P=(0,a._)("h2",{id:"токены",tabindex:"-1"},[(0,a._)("a",{class:"header-anchor",href:"#токены","aria-hidden":"true"},"#"),(0,a.Uk)(" Токены")],-1),U=(0,a.Uk)("Рассмотрим демонстрационную программу из "),G={href:"http://way23.ru/%D0%BD%D0%B0%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BF%D1%80%D0%BE%D1%81%D1%82%D0%BE%D0%B3%D0%BE-dsl-%D0%BA%D0%BE%D0%BC%D0%BF%D0%B8%D0%BB%D1%8F%D1%82%D0%BE%D1%80%D0%B0-%D0%BD%D0%B0-delphi-1/",target:"_blank",rel:"noopener noreferrer"},I=(0,a.Uk)("первой части"),y=(0,a.uE)('<div class="language-c ext-c line-numbers-mode"><pre class="language-c"><code><span class="token function">fib</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>\n  <span class="token keyword">if</span> i <span class="token operator">&lt;</span> <span class="token number">3</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token number">1</span>\n  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>\n    <span class="token keyword">return</span> <span class="token function">fib</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">fib</span><span class="token punctuation">(</span>i<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>\n  <span class="token punctuation">}</span>\n<span class="token punctuation">}</span>\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br></div></div><p>Из этого примера мы можем угадать все токены используемые в Языке</p><ul><li>identifier (&quot;fib&quot;, &quot;i&quot;, &quot;if&quot;, &quot;return&quot; ...)</li><li>number (&quot;1&quot;, &quot;2&quot;, &quot;3&quot;)</li><li>whitespace</li><li>left parenthesis (&quot;(&quot;)</li><li>right parenthesis (&quot;)&quot;)</li><li>left curly bracket (&quot;{&quot;)</li><li>right curly bracket (&quot;}&quot;)</li><li>less than (&quot;&lt;&quot;)</li><li>plus (&quot;+&quot;)</li><li>minus (&quot;-&quot;)</li></ul><p>Есть только два токена которые не покрывает этот пример</p><ul><li>comma (&quot;,&quot;)</li><li>semicolon (&quot;;&quot;)</li></ul><p>Первый используется для разделения параметров в определении функции и при вызове функции. Второй используется для разделения операторов, но не появляется в этом примере, так как является необязательным непосредственно перед закрывающей фигурной скобкой.</p><p>Следующий тип из модуля <code>SimpleDSL.Compiler.Tokenizer</code> перечисляет все варианты. В дополнение к уже обсуждённым типам токенов используются:</p><ul><li><code>tkUnknown</code> для представления неожиданных входных данных.</li><li><code>tkEOF</code> как сигнал что достигнут конец входного потока.</li></ul><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TTokenKind = (tkUnknown, tkWhitespace,\n                tkIdent, tkNumber,\n                tkLeftParen, tkRightParen, tkLeftCurly, tkRightCurly,\n                tkLessThan, tkPlus, tkMinus,\n                tkComma, tkSemicolon,\n\n                tkEOF);\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br></div></div><h2 id="интерфеис" tabindex="-1"><a class="header-anchor" href="#интерфеис" aria-hidden="true">#</a> Интерфейс</h2><p>Токинезатор доступен через очень простой интерфейс</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>ISimpleDSLTokenizer = interface\n  function  CurrentLocation: TPoint;\n  function  GetToken(var kind: TTokenKind; var identifier: string): boolean;\n  procedure Initialize(const code: string);\n  function  IsAtEnd: boolean;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Очень важная функция <code>GetToken</code>. Она возвращает следующий токен из входного потока — <code>kind</code> содержит тип токена и <code>identifier</code> содержит последовательность символов представляющих токен. Функция возвращает <code>False</code> когда достигнут конец входного потока.</p><p>Другие функции вспомогательные.</p><ul><li><code>IsAtEnd</code> возвращает <code>True</code> когда достигнут конец входного потока.</li><li><code>CurrentLocation</code> возвращает текущую строку и номер символа, это удобно для сообщений об ошибках.</li><li><code>Initialize</code> — инициализирует токинизатор.</li></ul><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TSimpleDSLTokenizer.Initialize(const code: string);\nbegin\n  FProgram.Text := code;\n  FNextLine := 0;\n  FNextChar := 1;\n  FLookahead := #0;\n  FLastLine := FProgram.Count - 1;\n  if FLastLine &gt;= 0 then begin\n    FLastLineLen := Length(FProgram[FLastLine]);\n    FCurrentLine := FProgram[FNextLine];\n  end;\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br></div></div><p>Программа хранится внутри <code>TStringList</code> <code>FProgram</code>. Другие переменные отслеживают текущее положение и чаще используются в методе <code>GetChar</code>.</p><h2 id="чтение-входного-потока" tabindex="-1"><a class="header-anchor" href="#чтение-входного-потока" aria-hidden="true">#</a> Чтение входного потока</h2><p>Давайте взглянем на метод <code>GetToken</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLTokenizer.GetToken(var kind: TTokenKind; var identifier: string): boolean;\nvar\n  ch: char;\nbegin\n  identifier := &#39;&#39;;\n  Result := GetChar(ch);\n  if not Result then begin\n    kind := tkEOF;\n    Exit;\n  end;\n  case ch of\n    &#39;(&#39;: kind := tkLeftParen;\n    &#39;)&#39;: kind := tkRightParen;\n    &#39;{&#39;: kind := tkLeftCurly;\n    &#39;}&#39;: kind := tkRightCurly;\n    &#39;+&#39;: kind := tkPlus;\n    &#39;-&#39;: kind := tkMinus;\n    &#39;&lt;&#39;: kind := tkLessThan;\n    &#39;,&#39;: kind := tkComma;\n    &#39;;&#39;: kind := tkSemicolon;\n    else if ch.IsLetter then begin\n      kind := tkIdent;\n      identifier := ch + GetIdent;\n    end\n    else if CharInSet(ch, [&#39;0&#39;..&#39;9&#39;]) then begin\n      kind := tkNumber;\n      identifier := ch + GetNumber;\n    end\n    else if ch.IsWhiteSpace then begin\n      kind := tkWhitespace;\n      SkipWhitespace;\n    end\n    else\n      kind := tkUnknown;\n  end;\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br></div></div><p>Сначала он считывает следующий символ из потока (через <code>GetChar</code>) и завершается если следующего символа нет. Затем обрабатывает все односимвольные токены сразу. После этого идет обработка особых случаев — чтение идентификаторов, строк, и пробелов через методы <code>GetIdent</code>, <code>GetNumber</code> и <code>SkipWhitespace</code> соответственно.</p><p><code>GetIdent</code> и <code>GetNumber</code> очень похожи, так что я сфокусируюсь на одном из них.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>function TSimpleDSLTokenizer.GetIdent: string;\nvar\n  ch: char;\nbegin\n  Result := &#39;&#39;;\n  while GetChar(ch) do begin\n    if ch.IsLetter or ch.IsNumber or (ch = &#39;_&#39;) then\n      Result := Result + ch\n    else begin\n      PushBack(ch);\n      Exit;\n    end;\n  end;\n\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br></div></div><p>Так как <code>GetToken</code> уже прочитал первый символ идентификатора, то <code>GetIdent</code> собирает вместе все следующие символы которые являются либо буквой, либо цифрой, либо символом подчёркивания. (и как вы можете видеть, код использует хелперы для типа <code>Char</code> - <code>IsLetter</code> и <code>IsNumber</code> — так что идентификаторы действительно поддерживают Юникод)</p><p>Когда появляется неподходящий для идентификатора символ, простейшее решение это просто сказать &quot;Оп, я прочитал слишком много, пожалуйста помести этот последний символ обратно для обработки&quot;.</p><h2 id="одно-символьныи-буфер" tabindex="-1"><a class="header-anchor" href="#одно-символьныи-буфер" aria-hidden="true">#</a> Одно-символьный буфер</h2><p>Раз мы только что прочитали на один символ больше, эта операция &quot;пожалуйста, верни последний <code>GetChar</code>&quot; обрабатывается простым одно-символьным буфером используемым в <code>PushBack</code> и в <code>GetChar</code>.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>procedure TSimpleDSLTokenizer.PushBack(ch: char);\nbegin\n  Assert(FLookahead = #0, &#39;TSimpleDSLTokenizer: Lookahead buffer is not empty&#39;);\n  FLookahead := ch;\nend;\n\nfunction TSimpleDSLTokenizer.GetChar(var ch: char): boolean;\nbegin\n  if FLookahead &lt;&gt; #0 then begin\n    ch := FLookahead;\n    FLookahead := #0;\n    Result := true;\n  end\n  else begin\n    Result := not IsAtEnd;\n    if Result then begin\n      ch := FCurrentLine[FNextChar];\n      Inc(FNextChar);\n      if FNextChar &gt; Length(FCurrentLine) then begin\n        Inc(FNextLine);\n        if FNextLine &lt; FProgram.Count then\n          FCurrentLine := FProgram[FNextLine];\n        FNextChar := 1;\n      end;\n    end;\n  end;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br></div></div><p><code>PushBack</code> просто сохраняет текущий буфер в <code>FLookahead</code> (если буфер не пуст, что может произойти только если в токенизере баг). <code>GetChar</code> содержит немного больше работы — в дополнение к обработке буфера <code>FLookahead</code> он должен также обрабатывать условие окончания строки текста.</p><p>Подход <em>PushBack</em> используется также в <code>GetNumber</code> и в <code>SkipWhitespace</code> (для деталей смотрите код) и в парсере, как мы скоро увидим.</p>',30),N={render:function(n,e){const s=(0,a.up)("OutboundLink");return(0,a.wg)(),(0,a.iD)(a.HY,null,[(0,a._)("h1",r,[i,(0,a.Uk)(" "+(0,l.zw)(n.$frontmatter.title),1)]),(0,a._)("p",null,[p,(0,a._)("a",t,[c,(0,a.Wm)(s)]),o]),(0,a._)("p",null,[u,(0,a._)("a",b,[d,(0,a.Wm)(s)]),m]),(0,a._)("p",null,[h,(0,a._)("a",k,[D,(0,a.Wm)(s)]),g]),f,(0,a._)("p",null,[B,(0,a._)("a",L,[F,(0,a.Wm)(s)]),v,(0,a._)("a",q,[C,(0,a.Wm)(s)]),w,(0,a._)("a",T,[x,(0,a.Wm)(s)]),S]),_,E,P,(0,a._)("p",null,[U,(0,a._)("a",G,[I,(0,a.Wm)(s)])]),y],64)}}}}]);