"use strict";(self.webpackChunkway23=self.webpackChunkway23||[]).push([[4772],{89542:(n,e,a)=>{a.r(e),a.d(e,{data:()=>s});const s={key:"v-73999100",path:"/%D0%B0%D0%B2%D1%82%D0%BE%D0%BC%D0%B0%D1%82%D0%B8%D1%87%D0%B5%D1%81%D0%BA%D0%BE%D0%B5-%D1%81%D0%BE%D0%B7%D0%B4%D0%B0%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B1%D1%8A%D0%B5%D0%BA%D1%82%D0%BD%D1%8B%D1%85-%D0%BF.html",title:"Автоматическое создание объектных полей с помощью RTTI в Delphi",lang:"ru-RU",frontmatter:{title:"Автоматическое создание объектных полей с помощью RTTI в Delphi",date:"2019-05-12",categories:["Delphi"],tags:["Delphi","rtti"]},excerpt:"",headers:[{level:2,title:"Проблема",slug:"проблема",children:[]},{level:2,title:"Результат",slug:"результат",children:[]},{level:2,title:"Решение",slug:"решение",children:[]},{level:2,title:"Создание объектов",slug:"создание-объектов",children:[]},{level:2,title:"Уничтожение полей",slug:"уничтожение-полеи",children:[]},{level:2,title:"Потенциальные проблемы",slug:"потенциальные-проблемы",children:[]}],filePathRelative:"автоматическое-создание-объектных-п.md",git:{updatedTime:1692859375e3}}},95408:(n,e,a)=>{a.r(e),a.d(e,{default:()=>B});var s=a(66252),r=a(3577);const l={id:"frontmatter-title",tabindex:"-1"},p=(0,s._)("a",{class:"header-anchor",href:"#frontmatter-title","aria-hidden":"true"},"#",-1),t=(0,s.Uk)("Вольный перевод поста "),i={href:"https://www.thedelphigeek.com/2012/10/automagically-creating-object-fields.html",target:"_blank",rel:"noopener noreferrer"},b=(0,s.Uk)("Automagically Creating Object Fields with RTTI"),c=(0,s.uE)('<p>На работе возникла задача создания иерархии классов, причём классы почти не содержали реализации, только объявление классов, с одним исключением — каждый класс отвечал за создание и уничтожение внутренних объектов. Я задумался, может быть, я могу использовать атрибуты и RTTI чтобы реализовать это поведение в одном месте, вместо того чтобы реализовывать в каждом классе.</p><h2 id="проблема" tabindex="-1"><a class="header-anchor" href="#проблема" aria-hidden="true">#</a> Проблема</h2><p>Мне нужны классы следующего вида</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TObjectB = class\n    FData1: integer;\n    FData2: string;\n    FData3: boolean;\n  end; \n\n  TObjectA = class\n  strict private\n    FObjectB: TObjectB;\n  public\n    constructor Create;\n    destructor Destroy; override;\n  end;\n\n{ TObjectA }\n\nconstructor TObjectA.Create;\nbegin\n  inherited Create;\n  FObjectB := TObjectB.Create;\nend;\n\ndestructor TObjectA.Destroy;\nbegin\n  FreeAndNil(FObjectB);\n  inherited;\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br></div></div><p>Но я слишком ленив чтобы писать в каждом классе раз примерно одинаковый конструктор и деструктор. Что мне делать?</p><h2 id="результат" tabindex="-1"><a class="header-anchor" href="#результат" aria-hidden="true">#</a> Результат</h2><p>Используя надлежащую инфраструктуру, код выше может быть переписан следующим образом</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TObjectB = class\n    FData1: integer;\n    FData2: string;\n    FData3: boolean;\n  end;\n\n  TObjectA = class(TGpManaged)\n  strict private\n    [GpManaged]\n    FObjectB: TObjectB;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br></div></div>',8),d=(0,s.Uk)("Вся реализация скрыта в классе "),o=(0,s._)("code",null,"TGpManaged",-1),u=(0,s.Uk)(", который описан ниже. Он реализован в модуле "),m={href:"https://github.com/gabr42/GpDelphiUnits/blob/master/src/GpAutoCreate.pas",target:"_blank",rel:"noopener noreferrer"},h=(0,s.Uk)("GpAutoCreate"),g=(0,s.Uk)(", который является частью моего open-source проекта "),T={href:"https://github.com/gabr42/GpDelphiUnits",target:"_blank",rel:"noopener noreferrer"},f=(0,s.Uk)("GpDelphiUnits"),D=(0,s.Uk)(", вместе с тестовой программой "),v=(0,s._)("code",null,"TestGpAutoCreate",-1),y=(0,s.Uk)("."),G=(0,s.uE)('<h2 id="решение" tabindex="-1"><a class="header-anchor" href="#решение" aria-hidden="true">#</a> Решение</h2><p>Класс <code>TGpManaged</code> реализует только конструктор и деструктор. Конструктор автоматически создаёт поля в классах-потомках, а деструктор автоматически уничтожает их.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  TGpManaged = class\n  public\n    constructor Create;\n    destructor  Destroy; override;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br></div></div><p>Не всегда хорошая идея автоматически создавать и уничтожать все поля. Поля, управление которыми будет проходить в автоматическом режиме, должны быть помечены атрибутом <code>[GpManaged]</code>, который реализован в этом же модуле.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>type\n  GpManagedAttribute = class(TCustomAttribute)\n  public type\n    TConstructorType = (ctNoParam, ctParBoolean);\n   strict private\n    FBoolParam      : boolean;\n    FConstructorType: TConstructorType;\n  public\n    class function  IsManaged(const obj: TRttiNamedObject): boolean; static;\n    class function GetAttr(const obj: TRttiNamedObject;\n      var ma: GpManagedAttribute): boolean; static;\n    constructor Create; overload;\n    constructor Create(boolParam: boolean); overload;\n    property BoolParam: boolean read FBoolParam;\n    property ConstructorType: TConstructorType read FConstructorType;\n  end;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br></div></div><p>Атрибут может быть указан в двух формах:</p><p>Первая форма <code>[GpManaged]</code> которая будет вызывать конструктор без параметров для создания объекта помеченного атрибутом.</p><p>Вторая форма <code>[GpManaged(false)]</code> или <code>[GpManaged(true)]</code> которая будет вызывать конструктор с одним параметром с типом Boolean для создания объекта помеченного атрибутом.</p><p>Поддержка конструкторов с другими типами параметров может быть добавлена в дальнейшем.</p><p>Вторая форма с параметром конструктора была добавлена специально для создания <code>TObjectList</code>. Вызывая <code>TObjectList.Create</code> будет создан список объектов, который будет отвечать за их уничтожение. Это удобно в большинстве случаев. Тем не менее, если вы хотите чтобы список не отвечал за уничтожение объектов вы можете создать его следующим образом</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>  [GpManaged(false)]\n  FList2: TObjectList;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br></div></div><p>Более детально реализацию <code>GpManagedAttribute</code> вы можете посмотреть в исходном коде.</p><h2 id="создание-объектов" tabindex="-1"><a class="header-anchor" href="#создание-объектов" aria-hidden="true">#</a> Создание объектов</h2><p>Поля помеченные любой версией атрибута <code>[GpManaged]</code> создаются в конструкторе <code>TGpManaged.Create</code>.</p><p>Код сначала обращается к расширенному контексту RTTI и ищет информацию об объекте который создаётся (<code>ctx.GetType(Self.ClassType)</code>). Потом происходит перебор всех полей объявленный в этом объекте.</p><p>Для каждого поля проверяется помечено ли оно атрибутом <code>[GpManaged]</code>. Если поле не отмечено то происходит переход к следующему полю.</p><p>Если же поле помечено <code>[GpManaged]</code>, то происходит цикл по всем методам с именем <code>Create</code> (я намеренно отказался от поддержки конструкторов с другими именами). Для каждого найденного метода происходит проверка, содержит ли он соответствующее число параметров и их типы.</p><p>Если соответствие найдено то используется <code>ctor.Invoke(f.FieldType.AsInstance.MetaclassType)</code> для вызова найденного конструктора. Подходящие параметры конструктора передаются вторым аргументом <code>Invoke</code>. Результат вызова конструктора помещается поле методом <code>f.SetValue</code>.</p><p>Затем вся процедура повторяется для следующего поля.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>constructor TGpManaged.Create;\nvar\n  ctor  : TRttiMethod;\n  ctx   : TRttiContext;\n  f     : TRttiField;\n  ma    : GpManagedAttribute;\n  params: TArray&lt;TRttiParameter&gt;;\n  t     : TRttiType;\nbegin\n  ctx := TRttiContext.Create;\n  t := ctx.GetType(Self.ClassType);\n  for f in t.GetFields do begin\n    if not GpManagedAttribute.GetAttr(f, ma) then\n      continue; //for f\n    for ctor in f.FieldType.GetMethods(&#39;Create&#39;) do begin\n      if ctor.IsConstructor then begin\n        params := ctor.GetParameters;\n        if (ma.ConstructorType = GpManagedAttribute.TConstructorType.ctNoParam) and\n           (Length(params) = 0) then\n        begin\n          f.SetValue(Self, ctor.Invoke(f.FieldType.AsInstance.MetaclassType, []));\n          break; //for ctor\n        end\n        else \n        if (ma.ConstructorType = \n             GpManagedAttribute.TConstructorType.ctParBoolean) and\n           (Length(params) = 1) and\n           (params[0].ParamType.TypeKind = tkEnumeration) and\n           SameText(params[0].paramtype.name, &#39;Boolean&#39;) then\n        begin\n          f.SetValue(Self, \n            ctor.Invoke(f.FieldType.AsInstance.MetaclassType, [ma.BoolParam]));\n          break; //for ctor\n        end;\n      end;\n    end; //for ctor\n  end; //for f\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br><span class="line-number">22</span><br><span class="line-number">23</span><br><span class="line-number">24</span><br><span class="line-number">25</span><br><span class="line-number">26</span><br><span class="line-number">27</span><br><span class="line-number">28</span><br><span class="line-number">29</span><br><span class="line-number">30</span><br><span class="line-number">31</span><br><span class="line-number">32</span><br><span class="line-number">33</span><br><span class="line-number">34</span><br><span class="line-number">35</span><br><span class="line-number">36</span><br><span class="line-number">37</span><br><span class="line-number">38</span><br></div></div><h2 id="уничтожение-полеи" tabindex="-1"><a class="header-anchor" href="#уничтожение-полеи" aria-hidden="true">#</a> Уничтожение полей</h2><p>Поля очищаются похожим образом, только взамен конструктора вызывается деструктор <code>Destroy</code>. Код проще потому что не требуется проверять каком именно деструктор вызывать.</p><div class="language-delphi ext-delphi line-numbers-mode"><pre class="language-delphi"><code>destructor TGpManaged.Destroy;\nvar\n  ctx : TRttiContext;\n  dtor: TRttiMethod;\n  f   : TRttiField;\n  t   : TRttiType;\nbegin\n  ctx := TRttiContext.Create;\n  t := ctx.GetType(Self.ClassType);\n  for f in t.GetFields do begin\n    if not GpManagedAttribute.IsManaged(f) then\n      continue; //for f\n    for dtor in f.FieldType.GetMethods(&#39;Destroy&#39;) do begin\n      if dtor.IsDestructor then begin\n        dtor.Invoke(f.GetValue(Self), []);\n        f.SetValue(Self, nil);\n        break; //for dtor\n      end;\n    end; //for dtor\n  end; //for f\nend;\n</code></pre><div class="line-numbers"><span class="line-number">1</span><br><span class="line-number">2</span><br><span class="line-number">3</span><br><span class="line-number">4</span><br><span class="line-number">5</span><br><span class="line-number">6</span><br><span class="line-number">7</span><br><span class="line-number">8</span><br><span class="line-number">9</span><br><span class="line-number">10</span><br><span class="line-number">11</span><br><span class="line-number">12</span><br><span class="line-number">13</span><br><span class="line-number">14</span><br><span class="line-number">15</span><br><span class="line-number">16</span><br><span class="line-number">17</span><br><span class="line-number">18</span><br><span class="line-number">19</span><br><span class="line-number">20</span><br><span class="line-number">21</span><br></div></div><h2 id="потенциальные-проблемы" tabindex="-1"><a class="header-anchor" href="#потенциальные-проблемы" aria-hidden="true">#</a> Потенциальные проблемы</h2><p>Вы должны всегда помнить что этот подход намного медленней чем создание объектов обычным образом. Я не делал тестов, но не буду удивлён если автоматическое создание объектов медленнее в 100 раз. Тем не менее, скорость достаточная для управления объектами которые редко создаются и уничтожаются.</p><p>Другая проблема заключается в том, что вы должны изменить предок своих классов на <code>TGpManaged</code>. Если это не подходит для вашей ситуации, но вы всё равно хотите использовать автоматическое управление жизненным циклом объектов, то вы должны скопировать мой код в ваши базовые классы.</p>',26),B={render:function(n,e){const a=(0,s.up)("OutboundLink");return(0,s.wg)(),(0,s.iD)(s.HY,null,[(0,s._)("h1",l,[p,(0,s.Uk)(" "+(0,r.zw)(n.$frontmatter.title),1)]),(0,s._)("p",null,[t,(0,s._)("a",i,[b,(0,s.Wm)(a)])]),c,(0,s._)("p",null,[d,o,u,(0,s._)("a",m,[h,(0,s.Wm)(a)]),g,(0,s._)("a",T,[f,(0,s.Wm)(a)]),D,v,y]),G],64)}}}}]);